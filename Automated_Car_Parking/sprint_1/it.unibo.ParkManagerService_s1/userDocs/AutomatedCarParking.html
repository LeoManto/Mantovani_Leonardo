<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body {
        margin-left: 30px;
        margin-right: 30px;
    }

    ;

    P {
        font-family: Tahoma;
        font-size: 10pt;
    }

    ;

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }


    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1,
    h2,
    h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }

    tt {
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }

    em {
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style: solid;
        border-color: #abe876;
        color: #1632cc;
    }

    bc {
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }

    ks {
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD;
        font-size: 90%;
    }

    kc {
        font-family: "Arial";
        font-weight: bold;
        color: #008000;
        font-size: 90%;
    }

    pre {
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }

    m {
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }

    div.body {

        font-size: 18px;
    }

    k {
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }

    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }

    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 95%;
        border-radius: 5px;
        padding: 2px;
    }

    h5 {
        background-color: #d5ffb0;
        font-size: 100%;

    }

    div.req {
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }

    div.remark {
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    div.remark2 {
        background-color: #F5F5DC;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }

    ol,
    ul,
    li {
        margin: 0;
        margin-left: 10px;
        padding: 0;
        padding-bottom: 5px;
    }

    table,
    th,
    td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed
    }

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }

    div.wrapdesc {
        width: 90%;
        margin: auto;
    }

    div.imagedesc {
        width: 85%;
        margin: auto;
    }
</style>

<head>

    <title>AutomatedCarParking</title>
</head>

<body>
    <div id="top">
        <h1>
            <font size="5">Automated Car-Parking</font>
        </h1>
    </div>

    <div class="body">
        <h2><a name="introduction"></a>Introduction - SPRINT 1</h2>
        <div class="remark">
            <p>This document contains a general analysis of the customer requirements. Then we will proceed to organize
                the developing process using
                <a href="https://scrumguides.org/">SCRUM</a> methodology for agile and incremental development, also in
                order to propose a first prototype as soon as possible.
            </p>
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <p>The requirements below are token from the file <a
                    href="../../../utils/TFBO21ParkingISS.pdf">TFBO21ParkingISS</a></p>

            A company intends to build an <i>automating parking service</i> composed of a set of elements:

            <ul>
                <li>A software system, named <em>ParkManagerService</em>, that implements the required automation
                    functions.
                </li>
                <li>A <tt>DDR</tt> robot working as a <em>transport trolley</em>, that is intially situated in its
                    <em>home</em> location.
                    The <tt>transport trolley</tt> has the form of a square of side length <em>RD</em>.
                </li>
                <li>A <em>parking-area</em> is an empty room that includes;
                    <ul>
                        <li>an <em>INDOOR</em> to enter the car in the area. Facing the <tt>INDOOR</tt>, there is
                            a <em>INDOOR-area</em> equipped with a <em>weightsensor</em> that measures the
                            <em>weight</em>
                            of the car;</li>
                        <li>an <em>OUTDOOR</em> to exit from the <tt>parking-area</tt>. Just after the <tt>OUTDOOR</tt>,
                            there is
                            <em>OUTDOOR-area</em> equipped with a <em>outsonar</em>, used to detect the presence of a
                            car.
                            The <tt>OUTDOOR-area</tt>, once engaded by a car, should be freed within a prefixed interval
                            of
                            time <em>DTFREE</em>; </li>
                        <li>a number <tt>N (N=6)</tt> of <em>parking-slots</em>;</li>
                        <li>a <em>thermometer</em> that measures the temperature <em>TA</em> of the area;</li>
                        <li>a <em>fan</em> that should be activated when <k>TA > TMAX</k>, where <em>TMAX</em> is a
                            prefixed
                            value (e.g. <tt>35</tt>)</li>
                    </ul>
                    A <em>map</em> of the parking area, represented as a grid of squares of side length <em>RD</em>,
                    is available in the file <a href="parkingMap.txt" target="code">parkingMap.txt</a>:
                    <pre>
|r, 0, 0, 0, 0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, <bc>X, X,</bc>  0, 0, 0, X, 
|0, 0, 0, 0, 0, 0, 0, X, 
|X, X, X, X, X, X, X, X, </pre>
                    The map includes the positions of the <tt>parking-slots</tt> (marked above with the symbol <k>X</k>)
                    and of the <em>fixed obstacles</em> in the area (the walls marked with the symbol <b>X</b>).
                    <br /><br />
                    The area marked with <k>X</k> is a sort of 'equipped area' upon which the <tt>transport trolley</tt>
                    cannot walk.
                    Thus, to get the car in the <tt>parking-slot</tt>
                    <ks>(2,2)</ks>, the <tt>transport trolley</tt> must
                    go in cell <ks>(1,2)</ks>.
                    <br /><br />

                    The proper scene for the WEnv is reported in: <a href="parkingAreaConfig.js"
                        target="code">parkingAreaConfig.js</a>


                    <center><img src="./img/parkingAreaZone.PNG" alt="parkingAreaZone.PNG" width="45%" height="32%" />
                    </center>
                </li>
                <li>a <em>parking-manager</em> (an human being) which supervises the state of the <tt>parking-area</tt>
                    and handles critical situations. </li>
            </ul>

            <div class="remark">
                The job of our company is to design, build and deploy the <em>ParkManagerService</em>.
            </div>
            The <tt>ParkManagerService</tt> should create the <tt>ParkServiceGUI</tt> (for the client)
            and the <tt>ParkServiceStatusGUI</tt> (for the manager) and then perform the following tasks:


            <ul>
                <li>
                    <hr />
                    <em>acceptIN</em>: accept the request of a client to park the car if there is at least one
                    <tt>parking-slot</tt> available,
                    select a free slot identified with a unique <tt>SLOTNUM</tt>.<br />
                    A request of this type can be elaborated only when the <k><tt>INDOOR-area</tt> is free</k>,
                    and the <tt>transport trolley</tt> is at <tt>home</tt> or working (<k>not stopped</k> by the
                    manager).
                    If the <tt>INDOOR-area</tt> is already engaged by a car, the request is not immediately processed
                    (the client could simply wait or could - optionally - receive a proper notice).
                    <br />
                <li><em>informIN</em>: inform the client about the value of the <tt>SLOTNUM</tt>.</li>
                If <k>SLOTNUM>0</k>:
                <ol>
                    <li><em>moveToIn</em>: move the <tt>transport trolley</tt> from its current localtion to the
                        <tt>INDOOR</tt> ;</li>
                    <li><em>receipt</em>: send to the client a receipt including the value of the <tt>TOKENID</tt> ;
                    </li>
                    <li><em>moveToSlotIn</em>: move the <tt>transport trolley</tt> from the <tt>INDOOR</tt> to the
                        selected
                        <tt>parking-slot</tt>;</li>
                    <li><em>backToHome</em>: if no other request is present, move the <tt>transport trolley</tt> to its
                        <tt>home</tt> location,
                        else <em>acceptIN</em> or <em>acceptOUT</em>.</li>
                </ol>

                If <k>SLOTNUM==0</k>:
                <ul>
                    <li><em>moveToHome</em>: if not already at home, move the <tt>transport trolley</tt> to its
                        <tt>home</tt> location.</li>
                </ul>

                <li>
                    <hr />
                    <em>acceptOUT</em>: accept the request of a client to get out the car with <tt>TOKENID</tt>.
                    A request of this type can be elaborated only when the <k><tt>OUTDOOR-area</tt> is free</k>
                    and the <tt>transport trolley</tt> is at <tt>home</tt> or working (<k>not stopped</k> by the
                    manager).
                    If the <tt>OUTDOOR-area</tt> is still engaged by a car, the request is not immediately processed
                    (the client could simply wait or could - optionally - receive a proper notice).

                    <ol>
                        <li><em>findSlot</em>: deduce the number of the parking slot (<em>CARSLOTNUM</em>) from the
                            <tt>TOKENID</tt>;</li>
                        <li><em>moveToSlotOut</em>: move the <tt>transport trolley</tt> from its current localtion to
                            the
                            <tt>CARSLOTNUM/parking-slot</tt> ;</li>
                        <li><em>moveToOut</em>: move the <tt>transport trolley</tt> to the <tt>OUTDOOR</tt> ;</li>
                        <li><em>moveToHome</em>: if no other request is present move the <tt>transport trolley</tt> to
                            its
                            <tt>home</tt> location; <br />
                            else <em>acceptIN</em> or <em>acceptOUT</em></li>

                    </ol>
                </li>
                <li>
                    <hr />
                    <em>monitor</em>: update the <tt>ParkServiceStatusGUI</tt> with the required information about the
                    state
                    of the system.
                </li>

                <li>
                    <hr />
                    <em>manage</em>: accept the request of the manager to stop/resume the behavior of the <tt>transport
                        trolley</tt>.
                </li>

            </ul>
            <h3>User stories</h3>
            As a <bc>client - parking phase</bc> :
            <ul>
                <li>I intend to use a <em>ParkServiceGUI</em> provided by the <tt>ParkManagerService</tt> to notify my
                    interest in <i>entering</i>
                    my auto in the <tt>parking-area</tt> and to receive as answer the number <em>SLOTNUM</em> of a free
                    parking-slot (<tt>1&lt;=SLOTNUM&lt;=6</tt>).
                    <tt>SLOTNUM<k>==0</k></tt> means that no free slot is available.

                </li>
                <li>If <tt>SLOTNUM <k>>0</k></tt>, I move my car in front to the <tt>INDOOR</tt>, get out of the car and
                    afterwards press a <em>CarEnter</em> button on the
                    <em>ParkServiceGUI</em>. Afterwards, the <tt>transport trolley</tt> takes over my car and moves it
                    from
                    the <tt>INDOOR</tt>
                    to the selected <tt>parking-slot</tt>.
                    The <tt>ParkServiceGUI</tt> will show to me a receipt that includes a (unique) <em>TOKENID</em>,
                    to be used in the <i>car pick up</i> phase.</li>
            </ul>

            As a <bc>client - car pick up phase</bc> :
            <ul>
                <li>I intend to use the <tt>ParkServiceGUI</tt> to submit the request to pick up my car, by sending the
                    <tt>TOKENID</tt> previously received. </li>
                <li>Afterwards, the <tt>transport trolley</tt> takes over my car and moves it from its
                    <tt>parking-slot</tt>
                    to the <tt>OUTDOOR-area</tt>.</li>
                <li>I move the car, so to free the <tt>OUTDOOR-area</tt>.
                </li>
            </ul>

            As a <bc>parking-manager</bc>:
            <ul>
                <li>I intend to use the <em>ParkServiceStatusGUI</em> provided by the <tt>ParkManagerService</tt>
                    to observe the <em>current state</em> of the <tt>parking area</tt>, including the value <tt>TA</tt>
                    of
                    the temperature,
                    the state of the <tt>fan</tt> and the state of the <tt>transport trolley</tt> (<k>idle, working or
                        stopped</k>).</li>
                <li>I intend to <em>stop</em> the <tt>transport trolley</tt> when <k>TA > TMAX</k>, activate the
                    <tt>fan</tt> and
                    wait until <k>TA &lt; TMAX</k>. At this time, I stop the <tt>fan</tt> and resume the behavior of the
                    <tt>transport trolley</tt>.
                    Hopefully, the <b>start/stop</b>
                    <ks>of the fan</ks> could also be automated by the <tt>ParkManagerService</tt>,
                    while the <b>start/stop</b>
                    <ks>of the transport trolley</ks> is always up to me.
                </li>

                <li>I expect that the <tt>ParkManagerService</tt> sends to me an <em>alarm</em> if it detectes that the
                    <tt>OUTDOOR-area</tt>
                    has not been cleaned within the <tt>DTFREE</tt> interval of time.</li>
            </ul>



            <h4>About the devices</h4>
            All the sensors (<tt>weightsensor</tt>, <tt>outsonar</tt>, <tt>thermometer</tt> ) and the <tt>fan</tt>
            should be
            properly simulated
            by mock-objects or mock-actors.

            <h4>When using a real robot</h4>
            No further requirement.

            <h4>When available a Raspberry and a sonar</h4>
            The <tt>outsonar</tt> could be a real device. We can simulate the presence/absence of a car.

            <h4>When using <k>only</k> the virtual robot or <k>no real sonar</k> available</h4>
            Consider the new requirement:
            <ul>
                <li>
                    <ks>authorize</ks>: allow a manager to use the <tt>ParkServiceStatusGUI</tt> only if she/he owns
                    <bc>
                        proper permissions</bc>.
                </li>

            </ul>
        </div>
        <h2>Requirement analysis</h2>
        <div class="remark">
            <h3>Meanings analysis</h3>
            <p>After interviewing client, meanings he associates with nouns have been clarified:</p>
            <ul>
                <li>
                    <ks>WeightSensor: </ks> is a sensor that provides weight of a car when it is located in the
                    INDOOR-area.
                </li>
                <li>
                    <ks>OutSonar: </ks>is a sensor that provide a signal if a car is located in the OUTDOOR-area.
                    Initially this sensor has the purpose of signaling the presence of a car in the OUTDOOR-area.
                    This component can be equipped with an internal timer, that signals if a car remains in the
                    OUTDOOR-area
                    longer than a certain threshold.
                </li>
                <li>
                    <ks>Thermometer: </ks> is a sensor that measures temperature of the environment.
                </li>
                <li>
                    <ks>ParkServiceGUI: </ks>this is the GUI associated with Clients. It allows clients to request
                    access to the
                    car park and to park their car. Through this GUI clients can receive, from the system, some
                    informations, that are necessary for
                    parking operations, such as the parking-slot assigned to them and the corresponding TOKENID.
                    This GUI also permits clients to make picking request, providing their TOKENID. From this moment <b>ParkServiceGUI</b> can be also called <b>ClientGUI</b>.
                </li>
                <li>
                    <ks>ParkServiceStatusGUI: </ks>this is the GUI associated with ParkingManager. It provides all the
                    tools concerning parking area management and various information on the status of the parking area
                    and its components. From this moment <b>ParkServiceStatusGUI</b> can be also called <b>ManagerGUI</b>.
                </li>
                <li>
                    <ks>Transport Trolley: </ks> is a <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.issLabStart/userDocs/devsDdr.html">DDR robot</a> that has the task of parking cars from INDOOR to an
                    assigned park-slot and, on a pickup request, of moving cars from park-slot to OUTDOOR.
                    Trolley have three operative state: <k>idle</k>, <k>working</k>, <k>stopped</k>.
                    <ul>
                        <li>
                            When he is in <k>idle</k> state, means that he don't has any request to serve. In this case
                            he returns to his main place (<k>HOME</k>).
                        </li>
                        <li>
                            When he is in <k>working</k> state, means that he has to serve (or is serving) a request.
                        </li>
                        <li>
                            When he is in <k>stopped</k> state, means that there are some problems in the environment
                            and the <ks>Parking Manager</ks> has manually stopped the trolley work.
                            When he is in this situation, Trolley immediately stops whatever type of work it is doing
                            and stays where he is.
                        </li>
                    </ul>
                </li>
                <li>
                    <ks>Home: </ks>is a specific point in the parking. When system starts or there are no pending request,
                    Trolley waits in home. It is situated in the north-west corner of room,
                    coordinates (0,0).
                </li>
                <li>
                    <ks>TOKENID: </ks> is the <k>UNIQUE</k> an identification number of the parking operation, strictly
                    associated with the client owner of the parked car.
                    This number will be used at the end when the client decides to pickup his car from the parking-area.
                </li>
                <li>
                    <ks>parking-slot:</ks> all parking-slot are numerated by an integer number in a range from 1 to 6. Each parking slot can be identified as a tuple of values (eg. <i>(3,2)</i>)
                    indicating the position of the parking spaces in the map.
                </li>
                <li>
                    <ks>map:</ks> it's a virtual representation of parking area, that shows and keep traces of every
                    event occurs into the parking.
                </li>
            </ul>

            <p>Regarding to actions (verbs):</p>
            <ul>
                <li>
                    When a client notify system that he wants to enter in the parking-area, receives an answer containing
                    the <k>SLOTNUM</k> assigned to him, which can be <k>0</k> or <k>> 0</k>.
                    His request will be processed when the <k>INDOOR</k> area is free.
                </li>
                <li>
                    When a client make request for withdraw his car from parking-area have to enter manually his <k>
                        TOKENID</k> on <b>ParkServiceGUI</b>.
                </li>
            </ul>
            <h3>First Naive Macro Architecture</h3>
            <p>
                The goal of this section is to show a naive architecture of our system in order to have a better
                vision of
                the interactions between components that compose it.
                In this first schema, we still consider components of system as generic entities and we don't yet
                describe kind of their interactions.
            </p>
            <center><img src="img/macroArchitectureRaw.png" width="40%"> </center>

            <ul>
                <li>
                    <k>ParkingSystem:</k> is the main component that handles functioning of the entire automated
                    parking. It triggers the sensors and receives their data, it sends to TrolleyCmd the actions that
                    need to be performed and comunicate with GUIs.
                <li>
                    <k>TrolleyCmd:</k> it's the component that directly interfaces with the real Trolley.
                <li>
                    <k>Trolley:</k> it's the physical Trolley that moves inside parking area and performs the commands
                    that it receives from TrolleyCmd.

                <li>
                    <k>WeightSensor:</k> it is the component that manages the data collected by the related sensor,
                    that detects presence of cars into the INDOOR area, and sends these data to ParkingSystem.
                    This component also has the goal to set INDOOR area state.
                <li>
                    <k>Sonar: </k> it is the component that manages the inputs received by the related sensor, that
                    detects the presence of cars in OUTDOOR area.
                    This component also has the goals to set OUTDOOR area state and to trigger its internal timer which
                    emits an alarm when a car is not withdrawn within time limit.

                <li>
                    <k>Thermometer:</k> it's the component that sends data about evironment temperature to Fan.
                <li>
                    <k>Fan:</k> it's the component that receives temperature data from Termometer and actives a cooling
                    system when temperature reaches the upper limit.
                <li>
                    <k>ClientGUI:</k> it's a graphic interface at the customer's disposal. It allows clients to submit a
                    parking or picking request to the ParkingSystem.
                <li>
                    <k>ManagerGUI:</k> it's a graphic interface at the manager's disposal. Its aim is to show the
                    internal state of parking area and it permits to stop or resume Trolley when necessary.

            </ul>

            <h3>First Macro Architecture</h3>
            <p>
                Via the following picture, we want to propose a first architecture in which we describe also the nature
                of components, reserving the chooices about the type of interactions for future phases.
            </p>
            <center><img src="img/macroModel.png" width="50%"> </center>

            <h4>Component Analysis</h4>
            <p>
                Most of our component should be <a
                    href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/userDocs/LabQakIntro2021.html">QAktor</a>,
                in order to get fast prototyping and executable model of the system.
            </p>
            <ul>
                <li>
                    <ks>parkingmanagerservice:</ks> we consider this component a QAktor.
                    It must receive informations from any sensors and messages from GUIs.
                    It also must send messages to several component, for example to activate sensors or
                    reply to parking customer requests.
                <li>
                    <ks>trolleyCmd:</ks> it will be obtained starting from a QAktor provided by the customer into the
                    project
                    <a
                        href="https://github.com/anatali/issLab2021/tree/main/it.unibo.qak21.basicrobot">it.unibo.qak21.basicrobot</a>.
                    In order to exploit this component, also ours will be a QAktor.
                    <br>
                    It receives messages from <b>parkingmanagerservice</b> which concerning the action that
                    <b>Trolley</b> have to perform.
                <li>
                    <ks>Trolley: </ks>Customer has provided us some components, with related <a
                        href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html#intro">documentation</a>,
                    that deal with several different type of trolley (real or virtual) we can use.
                    So we have the possibility to test our implementation on a virtual environment with a <i>virtual
                        trolley</i>, in order to obtain fastly our prototype.

                <li>
                    <ks>weightsensor: </ks>about this component, we don't have at our disposal any component to start with and so it could be
                    simulated by QAktor that sends messages to <b>parkingmanagerservice</b> about the weight of car that
                    is in <em>INDOOR area</em>.
                <li>
                    <ks>outsonar: </ks> customer provided to us a C library called <ks>SonarAlone.c</ks> and a kotlin
                    class called <ks>sonarHCSR04Support2021.kt</ks> that are necessary to using a physical
                    sonar to detect the presence of car in <em>OUTDOOR area</em>. For time reasons, this component could
                    be also simulated during first phases.
                <li>
                    <ks>fan:</ks> goal of this component is to manage a cooling system in order to lower the
                    temperature. We don't have at our disposal any component to start with,
                    so it could be a QAktor that receives information about temperature and actives a fan.
                <li>
                    <ks>thermometer:</ks> to manage thermometer informations, we don't have at our disposal any component to start with, so
                    it could be a QAktor. This Actor has to comunicate directly with <b>fan</b> about environment
                    temperature.
                <li>
                    <ks>clientGUI:</ks> it will create a graphic interface which implements a service that allows the
                    clients to start parking or picking operations, and to obtain informations about them.
                <li>
                    <ks>managerGUI:</ks> it will create a graphic interface which implements a service that has the goal
                    to show to manager all informations about the system state.
                    When needed, it has to also allow manager to stop and resume <b>Trolley</b>, through sending messages to
                    <b>parkingmanagerservice</b>.

            </ul>


        </div>
        <h2>Problem analysis</h2>
        <div class="remark">
            <p>
                As mentioned in the <a href="#introduction">Introduction</a> we will use SCRUM methodology, so this
                paper will cover SPRINT 1.
                <br>
                So, during this phase, we will not consider some components and functionalities, in order to obtain, as
                soon as possible, an executable model
                which shows basic features of the system.
            </p>
            <p>
                <h3>Assumptions</h3>
                <p>In this version are applied the simplifications below:</p>
                <li>no <k>GUI</k> will be implemented (neither for the client nor for the parking-manager);
                    <div class="remark2" ;>GUIs will not be implemented because, during these early stages of
                        project development, we will only carry out local tests. </div>
                <li>Actions of <k>Parking-Manager</k> will not be performed;
                    <div class="remark2">The manager performs its actions through the GUI, as it is not implemented
                        it cannot perform operations either</div>
                <li>
                    <k>Thermometer</k> and <k>fan</k> are not considered;
                    <div class=remark2>These sensors are not considered because in this phase, we want to consider
                        only the component to build a first woking prototype of the parking system as soon as possible.
                        They will be considered in the next SPRINT.</div>
                <li>
                    <k>Outsonar</k> and <k>WeightSensor</k> are components simulated by a software;
                    <div class=remark2>These sensors are simulated because they are not yet physically available.
                        It is possible that real <b>outsonar</b> will be used in future SPRINTs.</div>
                <li>We assume that <k>client</k> withdraws his car in time, before the alarm activation;
                    <div class=remark2>With this assumption, the timeout alarm will never be emitted.
                        At this stage, only "standard" customer behaviour will be taken into account. </div>
                <li>It will be simulated only a client;
                    <div class=remark2>Only one client is involved, because we want to consider only one iteration of
                        parking and picking operations.
                        Related to this, when client arrives, INDOOR and OUTDOOR are always free.</div>
                <li>"no slots available" scenario is not considered;
                    <div class=remark2>This assumption is necessary because, at this stage, it will be not yet consider
                        a component that handles parking slots status.</div>
                <li>Neither virtual nor real <k>Trolley</k> is expected
                    <div class="remark2">We want to show how the system works at logical level, without perform any
                        Trolley movements. </div>
                    <p> <i> The components that are ignored or simplified are fully implemented during future
                            SPRINTs.</i> </p>
            </p>

            <h3>A First Model</h3>

            <table style="width:50%" border="1">
                <tr>
                    <td style="width:20%">
                        <br>
                        <pre>
						<bc>Parking phase</bc> :
						<ul>
						<li>A simulated <b>client</b> sends a request <tt>reqenter</tt> to notify his interest in entering his car in the <em>parking-area</em>.
						<li><ks>[acceptIN]</ks> we assumed that at least one slot is free, the <em>INDOOR</em> is always free and the robot is not STOPPED.
						<li><ks>[informIN]</ks><b> parkingmanagerservive</b> sends the reply <tt>slotsnum(SLOTNUM)</tt> to <b>client</b>, <em>SLOTNUM</em> will be always simply 1 
(the case <em>SLOTNUM == 0</em> is not contemplated in this model).
						<li><b>client</b> moves the car in front of <em>INDOOR</em> and then he press the <em>CARENTER</em> button, so it's sended 
a request <tt>carenter</tt> to <b>parkingmanagerservive</b>.
						<li><b>parkingmanagerservive</b> emits an event <tt>carindoorarrival</tt>, to notify that a car is present in the <em>INDOOR-area</em>.
						<li>The <b>weightsensor</b> perceives <tt>carindoorarrival</tt> and emits a event <tt>weight(CARWEIGHT)</tt>.
						<li><ks>[moveToIn]</ks> it's simulated, with a delay, the movements of <b>Trolley</b> from his current position to <em>INDOOR</em>
						<li><ks>[receipt]</ks> <b>parkingmanagerservive</b> handles <tt>carenter</tt> and reply with <tt>receipt(TOKENID)</tt>.
						<li><ks>[moveToSlotIn]</ks> <b>Trolley</b> moves the car to his assigned slot, there is not a real movements but it's added a delay to simulate it.
						<li><ks>[moveToHome]</ks> there is an another delay to simulated Trolley returns to <em>HOME</em> (in this model there in only a client).
						</ul>
						<bc>Car pick up phase</bc> :
						<ul>
						<li><ks>[acceptOUT]</ks> The simulated <b>client</b> send a dispatch to notify his interest in pickup his car <tt>reqpickup(TOKENID)</tt>.
						<li><ks>[findSlot]</ks> in this model <em>TOKENID</em> is already the number of slot where the car is (<em>CARSLOTNUM</em>).
						<li><ks>[moveToSlotOut]</ks> it's simulated, with a delay, the movements of <b>Trolley</b> from his current position to <em>CARSLOTNUM</em>.
						<li><ks>[moveToOut]</ks> it's simulated the movements of <b>Trolley</b> to <em>OUTDOOR</em>.
						<li><b>parkingmanagerservive</b> emits an event <tt>caroutdoorarrival</tt>, to notify that a car is present in the <em>OUTDOOR-area</em>.
						<li>the <b>ousonar</b> perceives <tt>caroutdoorarrival</tt> and actives itself and its internal timer.
						<li>the timer of <b>outsonar</b> will be cancel when the <b>client</b> emits the event <tt>carwithdrawn</tt>, to notify that a car is left the <em>OUTDOOR-area</em>.
						<li>if timer (set to <tt>DTFREE</tt>) expires, <b>outsonar</b> emits an event <tt>timeout</tt> (which is not yet handled).		
						<li><ks>[moveToHome]</ks> there is an another delay to simulated Trolley returns to <em>HOME</em> (in this model there in only a client).
						</li>
						</ul>
						<bc>Parking-manager</bc>:
						<ul>
						<li>The features related to the <tt>parking manager</tt> and its GUI are not considered for the time being. 
Consequently, neither the thermometer or the fans are considered.
						<li>Any alarm (timeout) emitted by the <b>outsonar</b> is not managed and the <b>Trolley</b> can't be manually started/stopped.
						</ul>	
					</pre>
                    </td>
                </tr>
            </table>
            
            <h4>SLOTNUM handling</h4>
            <div class="remark2">
            At this first stage we assign to SLOTNUM always the value <k>"1"</k>. We do it this way because, by assumption of this Sprint, we are considering presence of single Client.
            </div>
            <h4>TOKENID handling</h4>
            <div class="remark2">
            At this first stage we assign to TOKENID always the value of <k>SLOTNUM</k> because we don't already care about security or randomless of TOKENID.
			</div>
			<h4>How sensor activation can be triggered?</h4>
			<div class="remark2">
                            <tt>weightsensor</tt> and <tt>outsonar</tt> must be triggered when a car is, respectively,
                            in INDOOR and OUTDOOR area.<br>
                            <k>parkingmanagerservice</k> is the only component who knows when a car is in INDOOR or
                            OUTDOOR area,
                            it can be notify it in two ways:
                            <ol>
                                <li>sending a <k>dispatch</k> to the sensor when a car is in the right area.
                                <li>emitting an <k>event</k>, since the sensor there are in the same context.
                            </ol>
                            During the analysis phase it can already be observed that the second solution is more
                            appropriate because
                            it is independent of the characteristics of the sensors and their quantity and position.
			</div>
            <h3>Logical Architecture</h3>
            <p>
                <table style="width:100%" border="1">
                    <tr>
                        <td style="width:50%;">
                            <p>Our system it will be composed by four <ks>actors</ks> in the same
                                context <tt>ctxParkingservice</tt> </p>
                            <p>Actors that we implement, will be of <ks><a
                                        href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/userDocs/LabQakIntro2021.html">QAktor</a>
                                </ks>
                                type.</p>
                            <ul>
                                <li><b>parkingmanagerservice</b>
                                <li><b>client</b>
                                <li><b>weightsensor</b> (mock-actor)
                                <li><b>outsonar</b> (mock-actor)
                            </ul>

                        </td>
                        <td>
                            <center><img src="./img/ActorsModel.png"></center>

                        </td>
                    </tr>
                    <tr>
                        <td>
                            <center>
                                <ks>parkingmanagerservice: </ks>
                            </center>
                            This QAktor represents the system. It handles all client's request: <tt>reqenter</tt>,
                            <tt>carenter</tt> and <tt>pickup</tt>.
                            It provides the clients the SLOTNUM and the TOKENID. It coordinates the movements of the
                            trolley(in this version they are only simulated with delays). <br>
                            This actor also triggers the activation of <tt>weightsensor</tt> and
                            <tt>outsonar</tt>.<br><br>
                            
                        </td>
                        <td>
                            <center>
                                <ks>client: </ks>
                            </center>
                            It replaces, in this version, the role of the <ks>ParkServiceGUI</ks>, in particular, for
                            the moment, it's simulated the
                            operations related to a single client.
                            It's the QAktor that sends the requests (<tt>reqenter</tt> and <tt>carenter</tt>) to the
                            system during the parking phase
                            and sends dispatch (<tt>pickup</tt>) during the picking phase.<br>


                        </td>
                    </tr>
                    <tr>
                        <td>
                            <center>
                                <ks>weightsensor: </ks>
                            </center>
                            </center><br>
                            This mock-actor generates a random value that represents the
                            weight of car in entrance and propagates it by emitting an event <tt>weightsensor</tt>.<br>
                            It starts the simulation when perceives the <k>carindoorarrival</k> event.
                            <br>
                            The purpose of this component is to ensure that a car in actual in INDOOR-area when a client
                            press the
                            <tt>carenter</tt> button. Weight simulation takes place only once for each car arrived at
                            INDOOR-area, after
                            that weight value is setted to 0.
                        </td>
                        <td>
                            <center>
                                <ks>outsonar: </ks>
                            </center>
                            This actor has a boolean variable <k>busy</k>, that indicates if
                            the car is present in the outdoor, so as to simulate a real sensor. It start the
                            simulation when perceives <k>caroutdoorarrival</k> event. When the simulation stats,
                            it's activated also an internal timer. <br>
                            This timer performs a countdown from <tt>DTFREE</tt> value, if it arrives to 0 it's
                            emitted an event <tt>timeout</tt>.
                            The countdown is implemented with a <a
                                href="https://en.wikipedia.org/wiki/Coroutine">Coroutine</a>,
                            called <tt>mainScope</tt> which is cancelled
                            <pre>mainScope.cancel()</pre> when the
                            outsonar detects the <k>carwithdrawn</k> event, indicating that the car has been taken out
                            of the OUTDOOR-area.
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <center><img src="img/logicalArchitecture.png" width="60%"></center>
                        </td>
                    </tr>
                </table>
            </p>
        </div>

        <h2>Test plans</h2>
        <div class="remark">
        <p>
            In this first test plan are considered only <ks>non-distributed</ks> tests.<br>
            <br>
            <kc>TestPlans0 goals:</kc>
            <ul>
                <li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b>
                    </k>. <br> <br>
                    In this testing plan are employed <tt>parkingmanagerservice</tt> and <tt>client</tt>. In particular,
                    to start system simulation <tt>client</tt> sends a request <tt>reqenter</tt> and the others messages
                    necessary to continue properly the entire workflow. Test is performed observing some significant
                    resouces updated by <tt>parkingmanagerservice</tt> so as to verify the correct functioning of the
                    system.
                    <div class=remark2>
                        <h3>Parking phase</h3>
                        It's tested if the value of <em>SLOTNUM</em> provided by the
                        <b>parkingmanagerservive</b> it's greater than 0 and if <em>TOKENID</em> provided to client it's
                        greater than 0 and equals to
                        <em>SLOTNUM</em> (this requirement is introduced by the assumptions made for sprint 1).
                        <h3>Picking phase</h3>
                        It's tested if the <em>TOKENID</em> provided by client is greater than 0.

                    </div>
                <li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
                    <br>
                    Here it's tested the correct behaviour of <tt>weightsensor</tt> and <tt>outsonar</tt>. During this
                    kind of test, like in the <k>integration test</k>, the components updates some resouces whose values
                    are observed and then checked.
                    <div class=remark2>
                        <h3>Testing the weightsensor</h3>
                        It's tested if the value provided by <b>weightsensor</b> when a car is in <em>INDOOR</em> it's
                        greater than 0
                        (indicating the actual presence of the car).
                        <h3>Testing the outsonar</h3>
                        It's tested if <b>outsonar</b> detects the presence of a car in <em>OUTDOOR</em>.
                        (indicating the actual presence of the car).

                    </div>
            </ul>

        </p>
    </div>

        <h2>Project</h2>
        <div class="remark">
<p>
    We now proceed with the project phase, where we show the implementation of our system having only the features provided by this SPRINT. 
	In particular we will see the implementation of 4 QAktors which living in the same context that is <b>ctxparkingmanagerservice</b> :
  <li><b>parkingmanagerservice</b>
  <li><b>client</b> (In this first phase this actor is necessary to simulate the functioning of ClientGUI).
  <li><b>weightsensor (mock)</b>
  <li><b>outsonar (mock)</b>
    
   
   
<p>

        <table>
            <tr>
                <td style="vertical-align:top;">
                    <center><b>CLIENT</b></center>
                    <center><i><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/src/parkingservice.qak">parkingservice.qak</a></i></center>
                    <pre>
State requestToEnter{
	println("client notify his interest in entering | CLIENT")
	request parkingmanagerservice -m reqenter : reqenter(client)
} Transition t0 
				whenTime 3000 -> noresponse
				whenReply slotsnum -> afterslotnum


State noresponse {
	println("No SLOTNUM received, System not correctly work")
}

State afterslotnum {
	onMsg(slotsnum : slotsnum (SLOTNUM)){
		[# SLOTNUM = payloadArg(0).toInt()	#]
		println("SLOTNUM = $SLOTNUM | CLIENT" )
		request parkingmanagerservice -m carenter : carenter(V) 
	} 
} Goto cartoindoor


State cartoindoor{	
}Transition t0 
				whenReply receipt -> afterreceipt


State afterreceipt{
	onMsg(receipt : receipt (TOKENID)){
		[# TOKENID = payloadArg(0).toInt() #]
		println("client's TOKENID is $TOKENID | CLIENT")
	}
} 
Transition t0
				whenTime 10000 -> reqpickup

State reqpickup{
	// ==========[acceptOUT]==========
	println("client notify his interest in picking his car | CLIENT")
	forward parkingmanagerservice -m pickup : pickup($TOKENID)
} Transition t0 
				whenEvent caroutdoorarrival -> pickupcar


State pickupcar{
	delay 2000 //in 2 secondi porta via l'auto da OUTDOOR
	emit carwithdrawn : cw(bye)
}  
</pre>

                </td>

                <td>
                    <center><b>PARKINGMANAGERSERVICE</b></center>
                    <center><i><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/src/parkingservice.qak">parkingservice.qak</a></i></center>

<pre>
State ready{
	println("waiting for client | SERVICE")
}
Transition t0 	whenMsg pickup   -> handleToken
				whenRequest reqenter -> acceptin 

State acceptin{
	printCurrentMessage
	onMsg(reqenter : reqenter( V )){
		[# var msg = payloadArg(0) #]
	}
	/*==========[acceptIN]==========*/
	[# SLOTNUM = 1 #] //Per ora Ã¨ settato manualmente in fase di test
	/*==========[informIN]==========*/
	updateResource [# "slotnum(${SLOTNUM})" #]
	replyTo reqenter with slotsnum : slotsnum ($SLOTNUM)
	/*==========[moveToIn]==========*/
	println("Trolley is moving to Indoor | SERVICE")
} Transition t0
				whenRequest carenter -> carenter
			
				
State carenter{
	[# indoorFree = false #]
	emit carindoorarrival : cia(car_arrived)  		
} Transition t0
			whenEvent weightsensor -> weightcheck
			
			
State weightcheck{
	onMsg(weightsensor : weight(W)){
		[# 
			WEIGHT = payloadArg(0).toInt()
			println("Weight: " + WEIGHT)
		#] 
		}
} Goto moveToSlotIn if [# WEIGHT > 0 #] else weightError	
			
			
State moveToSlotIn{
	/*==========[moveToSlotIn]==========*/
	println("Trolley moves from entrance to slot $SLOTNUM | SERVICE")
	[# indoorFree = true #]
} Goto receipt
				
			
State weightError{ 
	println("Car too light !!")
} Goto ready		
			
				
State receipt{ 
	[# var TOKENID = SLOTNUM #]	
	/*==========[receipt]==========*/
	replyTo carenter with receipt : receipt($TOKENID)
	updateResource [# "receipt(${TOKENID})" #]
	/*==========[moveToHome]==========*/
	println("Trolley moves to Home | SERVICE")
} Transition t0 
				whenTime 1000 -> ready  


State handleToken{
	onMsg (pickup : pickup(TOKENID)){
		/*==========[findSlot]==========*/
			[#  var TOKENIN = payloadArg(0) #] 
			updateResource [# "pickup(${TOKENIN})" #]
	}
	//elaborazioni sul tokenIN per ottenere lo slotnum corrispondente(non in questo modello)
	
	println("checking Trolley status | SERVICE")
}
Transition t0
			whenTime 500 -> picking  

 
State picking{	 	
	println("Trolley picking car | SERVICE")
	/*==========[moveToSlotOut]==========*/
	/*==========[moveToOut]==========*/
	delay 4000
	println("Car is in Outdoor area | SERVICE")
	/*==========[moveToHome]==========*/
	println("Trolley moves to Home | SERVICE")
	emit caroutdoorarrival : coa(car_outdoor)  
	[# outdoorFree = false #]
}
Transition t0 	whenTime 200 -> ready
</pre>
                </td>
            </tr>

        </table>
        <br>
        <ul>
            <li>
                <b>client</b> and <b>parkingmanagerservice</b> actors follow the logical functioning of the above model.
                <br>
                During the project phase it will be used <k>request/reply</k> messages for
                <tt>reqenter</tt>/<tt>slotsnum</tt> and <tt>carenter</tt>/<tt>receipt</tt>.
                Instead <tt>reqpickup</tt> message is fowarded via <k>dispatch</k> because there is no need for a reply
                from <b>parkingmanagerservice</b>.<br>
                Considering that there isn't a real or a virtual trolley, we have the necessity to simulate its moves
                and actions with some delays.
            </li>
            <li>
                In <ks>carenter</ks> and <ks>picking</ks> status, <b>parkingmanagerservice</b> emits an event to notify
                the presence of a car in <em>INDOOR</em> or <em>OUTDOOR</em> area.<br>
                In <ks>carenter</ks> it's emitted <tt>carindoorarrival</tt> to notify the occupation of <em>INDOOR</em>
                area, instead in <ks>picking</ks>
                it's emitted <tt>caroutdoorarrival</tt> to report the occupation of <em>OUTDOOR</em> area.
                These events are used to trigger <b>weightsensor</b> and <b>outsonar</b> that are mock-actors into the
                same context.
                It's necessary also another event for the correct functioning of <b>outsonar</b> i.e.
                <tt>carwithdrawn</tt> that is emitted by <b>client</b> to notify that current car has been taken away
                from <em>OUTDOOR</em> area.
                Each time that this kind of events are emitted, <b>parkingmanagerservice</b> modifies the values of
                variables related to <em>INDOOR</em> and <em>OUTDOOR</em> status.<br>
            </li>
          	<li>
              In <ks>receipt</ks> status, the value of <em>TOKEN</em> is sets equal to <em>SLOTNUM</em> ones.
         	 	</li>
            <li>
                <ks>weightcheck</ks> status handles the information received from <b>weightsensor</b> via the event
                <tt>weightsensor</tt>.
            </li>
        </ul>

        <table>

            <tr>
                <td style="vertical-align:top;">
                    <center><b>WEIGHTSENSOR</b></center>
                    <center><i><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/codedqak/weightsensorSimulator.kt">weightsensorSimulator.kt</a></i></center>

<pre>
class weightsensorSimulator (name : String ) : ActorBasic( name ) {
	
	var w = 0
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
    override suspend fun actorBody(msg: ApplMessage) {
  		if( msg.msgId() == "carindoorarrival" && msg.msgType() == "event") {
			simulateWeight()
		}
 	}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun simulateWeight(){
		
		    w = Random.nextInt(750, 3000)
	
		     val m4 = MsgUtil.buildEvent(name, "weightsensor", "weight($w)")
		     emit(m4)
		     
		     updateResourceRep( "weight($w)"  )
	
		     w = 0
	}
} 
</pre>
                </td>
                <td>
                    <center><b>OUTSONAR</b></center>
                    <center><i><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/codedqak/sonarSimulator.kt">
sonarSimulator.kt </a></i></center>
                    
<pre>
class sonarSimulator (name : String ) : ActorBasic( name ) {

var busy = false
val DTFREE  = 10 //seconds
var tmp     = DTFREE
	
private var mainScope = CoroutineScope(Dispatchers.Default)
		
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
    override suspend fun actorBody(msg: ApplMessage) {
  		if( msg.msgId() == "caroutdoorarrival" &&  msg.msgType() == "event") startSonar()
  		else if ( msg.msgId() == "carwithdrawn" &&  msg.msgType() == "event") stopSonar()
 	}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun startSonar(){
	
		 	busy = true
		 	updateResourceRep( "outsonar(${busy.toString()})"  )
		 	mainScope = CoroutineScope(Dispatchers.Default)
		    startTimer()
		}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun stopSonar(){
			
		 	busy = false
		 	updateResourceRep( "outsonar(${busy.toString()})"  )
		    mainScope.cancel()
		    tmp = DTFREE
		}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
 	fun startTimer(){
		mainScope.launch{
			  tmp = DTFREE
			  while( tmp > 0){  		
			  	tmp = tmp - 1 
			  	delay(1000)
	  }

	  val m1 = MsgUtil.buildEvent(name, "timeout", "timeout(alarm)")
	  emit(m1)
				}
	}
}
</pre>
                </td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li>This mock-actor is a component that has the aim to replicate with simulation the functioning of
                            a real weight sensor.
                        <li>This mock-actor waits until an event <tt>carindoorarrival</tt> is emitted. When it happens,
                            <b>WeightSensor</b> provides to generate a random integer within a specific range.
                            This value represents the weight of the just arrived car in <em>INDOOR</em>.
                            After generation of this value the actor emits an event <tt>weight</tt> in which is
                            contained the generated weight value.
                            At the end it resets the generated value and it comes back waitning for the next
                            <tt>carindoorarrival</tt> event.

                    </ul>

                </td>
                <td>
                    <ul>
                        <li>This mock-actor is a component that has the goal to replicate with simulation the functioning of
                            a real sonar equipped with a internal timer that handling a countdown.
                        <li>This mock-actor, when perceives a event with the ID <tt>caroutdoorarrival</tt>, launches the
                            function <i>startSonar()</i> which sets suddently variable <i>busy</i> at TRUE, indicating that
                            <em>OUTDOOR</em> area is occupied. Then it's activated a <i>Coroutine</i> that performs a
                            countdown from <i>DTFREE</i> to 0. If countdown expires, it's emitted an alarm event, called
                            <tt>timeout</tt>.
                        <li>Instead, when it perceives an event with ID <tt>carwithdrawn</tt>, it's launched function
                            <i>stopSonar()</i>, which sets <i>busy</i> variable to FALSE and cancels coroutineScope in
                            order to stop the countdown.
                    </ul>

                </td>
            </tr>
        </table>
        </div>
        <br>


        <h2>Testing</h2>
        <div class="remark">
        <a href="../test/it/unibo/parkingmanagerservicetest/TestPlan0.kt">TestPlan0.kt </a><br>
        Tests is built using CoapObserver provided by the costumer in the project <ks>it.unibo.qak21.basicrobot</ks> (<a
            href="../test/it/unibo/parkingmanagerservice/test/utils/CoapObserverForTesting.kt">CoapObserverForTesting.kt</a>).
        <br>
        <kc>Goals:</kc>
        <ul>
            <li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b></k>.
                <br> <br>
                In this testing plan are employed <tt>parkingmanagerservice</tt> and <tt>client</tt>. In particular, to
                start system simulation <tt>client</tt> sends a request <tt>reqenter</tt> and the others messages
                necessary to continue properly the entire workflow. Test is performed observing some significant
                resouces updated by <tt>parkingmanagerservice</tt> so as to verify the correct functioning of the
                system.
            </ul>
                <div class=remark2>
                    <h3>Parking phase</h3>
                    <p>It's tested if the value of <em>SLOTNUM</em> provided by the
                        <b>parkingmanagerservive</b> it's greater than 0 and if <em>TOKENID</em> provided to client is
                        greater than 0 and equals to
                        <em>SLOTNUM</em> (this requirement is introduced by the assumptions made for sprint 1).</p>
<table>
  <tr>
    <td>
<pre>
val channelForObserver = Channel<String>()
testingObserver!!.addObserver(channelForObserver!!, "slotnum")
clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")

println("+++++++++ testreqenter ")	

result = channelForObserver!!.receive()
println("+++++++++ testreqenter RESULT=$result +++++++++")
slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
assertTrue(slotnum > 0)

delay(2000)

//--------------------------------------------------------------------------------

testingObserver!!.addObserver(channelForObserver!!, "receipt")

clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")
println("+++++++++ testcarenter")	
result = channelForObserver!!.receive()
token = result.substringAfter("(",result).substringBefore(")",result).toInt()
assertTrue(token > 0)
println("+++++++++ testcarenter RESULT=$result +++++++++")
assertEquals(slotnum, token)

delay(4000)
</pre>
	</td>
  <td>
  <p>
  	It's used a <b>clientactor</b> to simulate sending of messages from real <b>client</b> to our system.<br>
    Are deployed two <i>Observer</i>, one for <tt>slotnum</tt> and the other for <tt>receipt</tt>, to check the values updated by <b>parkingmanagerservice</b>.
  </td>
  </tr>
   </table>
                    <h3>Picking phase</h3>
                    It's tested if the <em>TOKENID</em> provided by client is greater than 0.
  <br><br>                
  <table>
    <tr>
      <td>
<pre>
testingObserver!!.addObserver(channelForObserver!!, "pickup")
clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")

println("+++++++++ testpickup")
result = channelForObserver!!.receive()
println("+++++++++ testpickup RESULT=$result +++++++++")
assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() > 0)
</pre>
      </td>
      <td>
        For this test are deployed the same methodology used for "parking phase" test: there is an <i>Observer</i> that observes the updating of <tt>pickup</tt> resource.
      </td>
    </tr>
    </table>
                </div>
            <li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
                <br>
                Here it's tested the correct behaviour of <tt>weightsensor</tt> and <tt>outsonar</tt>. During this kind
                of test, like in the <k>integration test</k>, the components updates some resouces whose values are
                observed and then checked.
                <div class=remark2>
                    <h3>Testing the weightsensor</h3>
                  It's tested if the value provided by <b>weightsensor</b> when a car is in <em>INDOOR</em> it's
                    greater than 0
                    (indicating the actual presence of the car).
                  <br><br>
                  <table>
                    <tr>
                    <td>
<pre>             
val secondChannel = Channel<String>() 
var sensorObs = CoapObserverForTesting("obsweightsensor", "ctxparkingservice" ,"weightsensor", "5683")
sensorObs.addObserver(secondChannel,"weight")
println("+++++++++ testweightsensor")
var resultSensor = secondChannel.receive()
assertTrue(resultSensor.substringAfter("(",resultSensor).substringBefore(")",resultSensor).toInt() > 0 )
println("+++++++++ testweightsensor RESULT=$result +++++++++")
</pre>
                    </td>
                    <td>
                      For testing the correct functioning of <b>weightsensor</b> is instanced a new <i>Observer</i>, called <tt>obsweightsensor</tt>, which has the goal to observe <tt>weight</tt>
                      resource, updated by mock-actor <b>weightsensor</b>.
                    </td>
                    </tr>
                    </table>

                    
                    <h3>Testing the outsonar</h3>
                    It's tested if <b>outsonar</b> detects the presence of a car in <em>OUTDOOR</em>.
                    (indicating the actual presence of the car).
                  	<br><br>
                    <table>
                    <tr>
                    <td>
<pre>
val secondChannel = Channel<String>()
var sensorObs = CoapObserverForTesting("obsoutsonar", "ctxparkingservice" ,"outsonar", "5683")
sensorObs.addObserver(secondChannel,"outsonar")
println("+++++++++ testoutsensor1")
result = secondChannel.receive()
println("+++++++++ testoutsensor1 RESULT=$result +++++++++")
assertEquals("outsonar(true)", result)

delay(2000)
//--------------------------------------------------------------------------------------
			
println("+++++++++ testoutsensor2")
clientactor!!.emit(MsgUtil.buildEvent("client","carwithdrawn","cw(ok)"))
result = secondChannel.receive()
println("+++++++++ testoutsensor2 RESULT=$result +++++++++")
assertEquals("outsonar(false)", result)
</pre>
                    </td>
                    <td>
                    	For testing the correct functioning of <b>outsonar</b> is instanced a new <i>Observer</i>, called <tt>obsoutsonar</tt>, which has the goal to observe <tt>outsonar</tt>
                      resource, updated by mock-actor <b>outsonar</b>.
                    </td>
                    </tr>
                    </table>

                </div>
            </div>
    
        <h2>Deployment</h2>
        <div class="remark">
        The deployment of SPRINT 1 consists in a release on a
        <a href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_1">Github repository</a>.
    </div>
        <h2>Maintenance</h2>
        <div class="remark">
        This is the first Sprint, more features will be released in the next (Second) Sprint.
        <br>
    </div>  

    <div style="background-color:rgba(42, 7, 241, 1.0); width:100%;text-align:center;color:white">
        <table style="width:100%" border="1">
            <tr>
                By Mantovani Leonardo and Pier Domenico d'Amicis

            </tr>
        </table>
    </div>
</body>

</html>
