<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
	body {
		margin-left: 30px;
		margin-right: 30px;
	}

	;

	P {
		font-family: Tahoma;
		font-size: 10pt;
	}

	;

	a,
	a:visited,
	a:active,
	a:link,
	a:hover {
		text-decoration: underline;
		color: #545454;
		background-color: transparent;
		font-size: 93%;
	}

	a:hover {
		background-color: #cccccc;
	}


	hr {
		clear: both;
		height: 1px;
		color: #242424;
		background-color: transparent;
	}

	h1,
	h2,
	h3 {
		color: #242424;
		clear: left;
		font: 100% Tahoma, Helvetica, Arial, sans-serif;
		margin-bottom: 0.5em;
		padding-top: 0.5em;
		border-radius: 10px;
		padding: 5px;
	}

	top {
		width: 100%;
	}


	#i {
		color: #ff1010;
	}

	tt {
		font-family: "Arial";
		font-size: 90%;
		color: #006600;
	}

	div.remark2 {
		background-color: #F5F5DC;
		border: 1.5px solid #d5f2ed;
		padding: 15px;
		margin: 10px;
		border-radius: 25px;
	}


	em {
		font-family: "Arial";
		font-size: 80%;
		font-weight: bold;
		border-style: solid;
		border-color: #abe876;
		color: #1632cc;
	}

	bc {
		font-family: "Arial";
		font-size: 90%;
		font-weight: bold;
		color: #990000;
		background-color: #fcf8c7;
	}

	ks {
		font-family: "Arial";
		font-weight: bold;
		color: #0000CD;
		font-size: 90%;
	}

	kc {
		font-family: "Arial";
		font-weight: bold;
		color: #008000;
		font-size: 90%;
	}

	pre {
		font-family: "Consolas";
		font-size: 85%;
		background-color: #f5f5f5;
		border: 1.5px solid silver;
		padding: 5px;
	}

	m {
		font-family: "Helvetica";
		line-height: 100%;
		font-size: 75%;
	}

	div.body {

		font-size: 18px;
	}

	k {
		color: #990000;
		font-weight: bold;
		font-size: 90%;
	}

	h1 {
		font-size: 150%;
		background-color: #b2c0ff;
		padding: 10px;
	}

	h2 {
		background-color: #9ed8ff;
		font-size: 130%;
	}

	h3 {
		background-color: #e6ccff;
		font-size: 100%;
	}

	h4 {
		background-color: #ccffcc;
		font-size: 100%;
		width: 95%;
		border-radius: 5px;
		padding: 2px;
	}

	h5 {
		background-color: #d5ffb0;
		font-size: 100%;

	}

	div.req {
		background-color: #d9ffb3;
		font-size: 18px;
		width: 700px;
		border: 3px solid green;
		padding: 15px;
		margin: 10px;
	}

	div.remark {
		background-color: #E3F2FD;
		border: 1.5px solid #d5f2ed;
		padding: 15px;
		margin: 10px;
		border-radius: 25px;
	}

	table,
	th,
	td {
		border: 1px solid black;
		border-collapse: collapse;
	}

	ol,
	ul,
	li {
		margin: 0;
		margin-left: 10px;
		padding: 0;
		padding-bottom: 5px;
	}

	table,
	th,
	td {
		border: 1px solid black;
	}

	img {
		border: 1.5px solid #d5f2ed
	}

	a,
	a:visited,
	a:active,
	a:link,
	a:hover {
		text-decoration: underline;
		color: #545454;
		background-color: transparent;
	}

	div.wrapdesc {
		width: 90%;
		margin: auto;
	}

	div.imagedesc {
		width: 85%;
		margin: auto;
	}
</style>

<head>

	<title>AutomatedCarParking</title>
</head>

<body>
	<div id="top">
		<h1>
			<font size="5">Automated Car-Parking</font>
		</h1>
	</div>

	<div class="body">
		<h2><a name="introduction"></a>Introduction - SPRINT 2</h2>
		<div class="remark">
			<p>In this document it will be analysed the second SPRINT of the project.
				In this phase we will extend previous SPRINT's model, adding more features and removing some
				semplifications,
				introduced during <a href="https://htmlpreview.github.io/?https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/userDocs/AutomatedCarParking.html">first SPRINT</a>.
			</p>
		</div>

		<h2>Problem analysis</h2>
		<div class="remark">
			<p>As mentioned in the <a href="#introduction">Introduction</a> in this SPRINT, we will analyze a simplified
				version (with less functionality) of the final system.
				<p>
					<h3>Assumptions</h3>

					In this version are applied the simplifications below:
					<br><br>
					<ul>
						<li>no <k>GUI</k> will be implemented (neither for the client nor for the parking-manager);
							<div class="remark2">GUIs will not be implemented because, during these early stages of
								project development, we will only carry out local tests.</div>

						<li>Actions of <k>Parking-Manager</k> will not be performed;
							<div class="remark2">The manager performs its actions through the GUI, as it is not
								implemented
								it cannot perform operations either</div>

						<li>
							<k>Outsonar</k> and <k>WeightSensor</k> are components simulated by a software;
							<div class=remark2>These sensors are simulated because they are not yet physically
								available.
								It is possible that real <b>outsonar</b> will be used in future SPRINTs.</div>

						<li>
							<k>Thermometer</k> and <k>fan</k> are components simulated by a software. Reaching the
							maximum temperature does not allow the Parking Manager (which is not yet considered) to stop
							the Trolley
							<div class=remark2>Since neither <tt>Trolley</tt> and <tt>Parking Manager</tt> are not yet
								considered, when the maximum temperature si reached no action will be performed.
								Activation of <k>fan</k> will be automatized.</div>



						<li>The alarm that is emmited if <k>outsonar timer</k> expires does not causes any action;
							<div class=remark2>
								The alarm is not handled at software level, no actions will be performed.
							</div>

						<li>Neither virtual nor real <k>Trolley</k> is expected;
							<div class="remark2">We want to show how the system works at logical level, without perform any Trolley movements.</div>

					</ul>
				</p>

				<h3>Model - SPRINT 2</h3>
				<br>
				<table style="width:100%; border:1px solid; font-family: Consolas; background-color:#f5f5f5;">
					<tr>
						<td>
							<center>
								<ks>parkingmanagerservice</ks>
							</center>
						</td>
						<td>
							<center>
								<ks>client</ks>
							</center>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<center>
								<bc>Parking Phase</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td style="width:50%">
							<br>
							<ul style="font-family: Consolas; font-size: 15px">
								<li>It checks if <em>INDOOR</em> is free and if there is at least one
									<tt>parking-slot</tt>
									available.
								<li>After the checks it is determined if <tt>reqenter</tt> can be accepted.
								<li>It's received the request <tt>reqenter</tt> sended by a <b>client</b>.</li>
								
								<li>If <em>INDOOR-area</em> is FREE the request is immediately elaborated, otherwise
									<b>client</b> receives <tt>waitIndoor(SLOTNUM)</tt> and waits until the <em>INDOOR-area</em> become FREE.		
									
								<li><ks>[acceptIN]</ks> It's generated <em>SLOTNUM</em> and the related slot is marked
									as occupied.
									
								<li><ks>[informIN]</ks><b> parkingmanagerservive</b> sends the reply
									<tt>slotsnum(SLOTNUM)</tt> to <b>client</b>.
								
								<li>It's received the request <tt>carenter</tt> sended by the <b>client</b>.
								
								<li><ks>[moveToIn]</ks> it's simulated, with a delay, the movements of <b>Trolley</b>
									from
									his current position to <em>INDOOR</em>
								
								<li><b>parkingmanagerservive</b> emits an event <tt>carindoorarrival</tt>, to notify
									that
									the client's car is in <em>INDOOR-area</em>.
								<li>The <b>weightsensor</b> perceives <tt>carindoorarrival</tt> and emit the event
									<tt>weight(CARWEIGHT)</tt>.
								<li><em>INDOOR</em> is marked as occupied.
								<li>
									<ks>[moveToSlotIn]</ks> If the weight obtained from <b>weightsensor</b> notifies the
									effective presence of a car in <em>INDOOR-area</em>,
									<b>Trolley</b> takes the car and moves it to slot assigned to it, there is not a
									real movements but it's added a delay to simulate it.
								<li><em>INDOOR</em> is marked as free.
								<li>
									<ks>[receipt]</ks> It's generated the <em>TOKENID</em> related to <em>SLOTNUM</em>
									assigned to <b>client</b> and reply to him
									with <tt>receipt(TOKENID)</tt>.
								<li>
									<ks>[moveToHome]</ks> There is an another delay to simulated Trolley returns to
									<em>HOME</em> if there are no more requests.
							</ul>
						<td>
							<ul style="font-family: Consolas; font-size: 15px">
								<li><b>client</b> sends a request <tt>reqenter</tt> to notify his interest in
									entering his car in the <em>parking-area</em>.
								<li>If <em>SLOTNUM > 0</em> and <em>INDOOR-area</em> is FREE, <b>client</b> moves the car in front of <em>INDOOR</em>,
									(press the <em>CARENTER</em> button) and send the request <tt>carenter</tt> to <b>parkingmanagerservive</b>, otherwise
									<b>client</b> waits for the <em>INDOOR-area</em> to become FREE.
							</ul>
						</td>
					<tr>
						<td colspan=2>
							<center>
								<bc>Car pick up phase</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td>
							<ul style="font-family: Consolas; font-size: 15px">
								<li>It checks if <em>OUTDOOR</em> is free.
								<li>After the checks it is determined if <tt>pickup</tt> can be elaborated.
								<li>
									<ks>[acceptOUT]</ks> It's received the dispatch <tt>pickup(TOKENID)</tt> sended by a
									<b>client</b>.
								<li>
									<ks>[findSlot]</ks> It's obtained the <em>CARSLOTNUM</em> from <tt>TOKENID</tt>
									sended
									by <b>client</b>.
								<li>
									<ks>[moveToSlotOut]</ks> it's simulated, with a delay, the movements of
									<b>Trolley</b>
									from his current position to <em>CARSLOTNUM</em>.
								<li>
									<ks>[moveToOut]</ks> it's simulated the movements of <b>Trolley</b> to
									<em>OUTDOOR</em>
								<li><em>OUTDOOR</em> is marked as occupied.
								<li>The slot corrisponding to <em>CARSLOTNUM</em> is marked as free.
								<li><b>parkingmanagerservice</b> emits an event <tt>caroutdoorarrival</tt>.
								<li>The <b>ousonar</b> perceives <tt>caroutdoorarrival</tt> and actives itself and its
									internal timer.
								<li>Timer of <b>outsonar</b> will be cancel when the <b>client</b> emits the event
									<tt>carwithdrawn</tt>.
								<li>If timer (set to <tt>DTFREE</tt>) expires, <b>outsonar</b> emit an event
									<tt>timeout</tt> (which is not yet handled).
								<li>
									<ks>[moveToHome]</ks> There is an another delay to simulated Trolley returns to
									<em>HOME</em> if there are no more requests.
								</li>
							</ul>
						</td>
						<td>
							<ul style="font-family: Consolas; font-size: 15px">
								<li><b>client</b> send a dispatch to <b>parkingmanagerservice</b>
									<tt>pickup(TOKENID)</tt>
									to notify his interest in
									in picking his car from parking-area.
								<li>When the car is in <em>OUTDOOR-area</em>, the <b>client</b> takes his car away, then
									emit an event <tt>carwithdrawn</tt>.
							</ul>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<center>
								<bc>Parking-manager</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<ul style="font-family: Consolas; font-size: 15px">
								<li>The features related to the <tt>parking manager</tt> and its GUI are not considered
									for
									the time being.
									Consequently, neither the thermometer or the fans are considered.
								<li>Any alarm (timeout) emitted by the <b>outsensor</b> is not managed.
							</ul>
						</td>

					</tr>
				</table>

				<h4>Handling of <k>Parking</k> and <k>Picking</k> requests (check state)</h4>
                <p>In this second SPRINT we have introduced a check, in order to verify if <tt>reqenter</tt> and
                    <tt>pickup</tt> sended by a <b>client</b> can be accepted by <b>parkingmanagerservice</b>.</p>
                <p>
                    The <tt>reqenter</tt> will be accepted if:
                    <ul>
                        <li>There is at least a free parking slot;
                    </ul>

                    By requirements, <tt>reqenter</tt> can be accepted only if there is at least one parking-slot
                    available, and can be subsequently elaborated in case of the <em>INDOOR-area</em> is free.
                    <br>If <em>INDOOR-area</em> is occupied, <b>parkingmanagerservice</b> send to <b>client</b> a
                    message <tt>waitIndoor</tt> to notify him that at this moment he can't bring his car to
                    <em>INDOOR-area</em> and that He have to wait.
                </p>
                <p>
                    The <tt>picking</tt> will be accepted if:
                    <ul>
                        <li><em>OUTDOOR-area</em> is free;</li>
                    </ul>
                </p>


				<h4>TokenID handling</h4>
				<p>In previous SPRINT, the <tt>TokenID</tt> was simply a value equals to <tt>SLOTNUM</tt> value, but now
					it's appropriate to generate a
					UNIQUE TokenID that is uniquely linked to <tt>SLOTNUM</tt>.
					So, in this version, <tt>TOKENID</tt> is a code composed by 5 digits of which the first indicates
					the <tt>SLOTNUM</tt> and the others are
					4 random digits that are added for safety reason.
				</p>
				<p>
					Furthermore all generated <tt>TOKENID</tt> are saved into a file, <ks>tokens.txt</ks>. <br>
					When a <tt>pickup(TOKENID)</tt> message arrives to <b>parkingmanagerservice</b>, it's performed a
					check that establishes
					if the inserted <tt>TOKENID</tt> is valid (if it is present in the).<br>
					While when a car is picked by a <b>client</b> his related <tt>TOKENID</tt> is deleted from file.
				</p>

				<h4>Fan and Thermometer</h4>
				<p>
					<b>Fan</b> and <b>Thermometer</b> are two components simulated by software:
					<ul>
						<li>
							<k>Thermometer</k> simulated the measurement of parking temperatures, in particular It is considered 
							that the temperature increases progressively due to the operation of machinery within the automated car park. 
						<li>
							<k>Fan</k> continuously reads the temperature measured by the thermometer and checks that it
							does not exceed a certain threshold.<br>
							When the maximum temperature is reached, <b>Fan</b> actives itself, simulating the switching
							on of some fans whose task is to lower the temperature of the car park.<br>
							The <b>Fan</b> keeps in working until the temperature reaches a certain minimun threshold,
							then it deactive itself.
					</ul>
				</p>

				<h4>ParkingSlotKb</h4>
				<p>
					It's necessary to introduce a knowledge base, to permit the system to know and modify the status of
					<em>parking slots</em> and <em>INDOOR</em> and
					<em>OUTDOOR</em> areas.<br>
					As a data structure to manage the slots of parking area, it can be using a <b>boolean array</b>, while to
					represent the <em>INDOOR</em> and
					<em>OUTDOOR</em> areas status, it' possible using two <b>boolean variables</b>. <br>
					A possible way of implementing this knowledge base can be seen in the file <a
						href="..\resources\it\unibo\utils\ParkingSlotsKb.kt">ParkingSlotKb.kt</a>.
				</p>

				<h4>External tools</h4>
				<p>
					At this stage it is useful to create tools to test the functioning of the system. <br>
					Since no real GUIs are implemented yet, a python script has been created that sends
					messages to the <b>parkingmanagerservice</b> as if it were a remote client.<br>
					The file is called <a href="..\ClientGUIsimulator.ipynb">ClientGUIsimulator.ipynb</a> and it must be
					launched using <ks>jupyter notebook</ks>.
				</p>


				<!-- Dobbiamo dire DOPO che sono i sensori ad impostare se le aree sono libere o no -->

				<h3>Logical Architecture</h3>
				<p>
					<table style="width:100%" border="1">
						<tr>
							<td style="width:50%;">
								<p>Our system <tt>ParkingManagerService</tt> it's composed by four <ks>actors</ks> in
									the
									same
									context <tt>ctxParkingservice</tt>, everyone of them
									providing a different service.</p>
								<p>Actors that we implement, will be of <ks><a
											href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/userDocs/LabQakIntro2021.html">QActor</a>
									</ks>
									type.</p>
								<ul>
									<li><b>parkingmanagerservice</b>
									<li><b>client</b>
									<li><b>weightsensor</b> (mock-actor)
									<li><b>outsonar</b> (mock-actor)
									<li><b>thermometer</b> (mock-actor)
									<li><b>fan</b> (mock-actor)
								</ul>

							</td>
							<td>
								
								<center><img src="./img/actors.png"></center>

							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>parkingmanagerservice: </ks>
								</center>
								This QActor represents the system. It handles all client's request: <tt>reqenter</tt>,
								<tt>carenter</tt> and <tt>pickup</tt> and performs some check to verify is it's possible to accept and manage them.
								It provides the clients the SLOTNUM and the TICKETID. It coordinates the movements of the
								trolley (in this version they are only simulated with delays). <br>
								This actor also triggers the activation of <tt>weightsensor</tt> and
								<tt>outsonar</tt>.<br><br>
								
							</td>
							<td>
								<center>
									<ks>client: </ks>
								</center>
								It's the QActor that sends the requests (<tt>reqenter</tt> and <tt>carenter</tt>) to the
								system during the parking phase
								and sends dispatch (<tt>pickup</tt>) during the picking phase.<br>
								It replaces, in this version, the role of the <ks>ParkServiceGUI</ks>, in particular,
								for
								the moment, it's simulated the
								operations related to a single client.

							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>weightsensor: </ks>
								</center>
								</center><br>
								This mock-actor generates a random value that represents the
								weight of car in entrance and propagates it by emitting an event
								<tt>weightsensor</tt>.<br>
								It starts the simulation when perceives the <k>carindoorarrival</k> event.
								It has also the task to set <em>INDOOR-area</em> status, when he perceives the precense or absence of a car in this area.
							</td>
							<td>
								<center>
									<ks>outsonar: </ks>
								</center>
								This actor has a boolean variable <k>busy</k>, that indicates if
								the car is present in the outdoor, so as to simulate a real sensor. It start the
								simulation when perceives <k>caroutdoorarrival</k> event. <br>
								It has tha aim to set <em>OUTDOOR-area</em> status when perceives the precense or absence of a car in the related area.
								When the simulation stats, it's activated also an internal timer. <br>
								This timer performs a countdown from <tt>DTFREE</tt> value, if it arrives to 0 it's
								emitted an event <tt>timeout</tt>.
								The countdown is implemented with a <a
									href="https://en.wikipedia.org/wiki/Coroutine">Coroutine</a>,
								called <tt>mainScope</tt> which is cancelled
								<pre>mainScope.cancel()</pre> when the
								outsonar detects the <k>carwithdrawn</k> event, indicating that the car has been taken
								out
								of the OUTDOOR-area.
							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>thermometer: </ks>
								</center>
								</center><br>
								This mock-actor is activated immediately at the start of application. It performs two
								different task:
								<li>emit continuously an event, in which are the actual temperature of environment</li>
								<li>to cyclically increment the value of temperature, this to simulate the increasing of
									environment temperature during his activity</li>
								For it's coherence with requirements, we have fixed a constant value
								<ks>maxTemp</ks> that indicates upper temperature limits of system operation. <br> It's
								necessary to decide a value that represent the optimal temperature at which fan can be
								stopped, we indicate this with constant value <k>minTemp</k>.
								When temperature has reached the upper limit, fan actor send to thermometer a dispatch
								message <tt>stopinc</tt>, which has the function of ending temperature increase process.
								On the other hand, when the temperature has returned to the working values, this is
								reported through an event <tt>normtemp</tt> emitted by fan, the process of increasing
								the temperature can restart.
							</td>
							<td>
								<center>
									<ks>fan: </ks>
								</center>
								This mock-actor is strictly related with thermometer actor. It evaluates every
								<tt>temp</tt> event that thermometer emit and check if the temperature of the
								environment
								is under the max prefixed temperature values. If temperature exeed the limits, fan actor
								send a dispatch message <tt>stopinc</tt> to the thermometer; this message is required to
								stop execution of increasing process.<br>
								When fan stat his execution, it start to decrease temperature, until this reaches <k>
									minTemp</k>. Then an event is emitted <tt>normtemp</tt> that warns that the
								simulation can restart adn fan actor terminate his work.
							</td>
						</tr>
						<tr>
							<td colspan="2">
								<center><img src="img/logicalArchitecture.png"></center>
							</td>
						</tr>
					</table>
				</p>
				
		</div>
		
		<h2>Test plans</h2>
		<p>
			In this test plan are considered only <ks>non-distributed</ks> tests.
			<br>
			<br>
			<kc>TestPlans goals:</kc>
			<ul>
				<li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b>
					</k>. <br> <br>
					In this testing plan are employed <tt>parkingmanagerservice</tt> and <tt>client</tt>. In particular,
					to start system simulation <tt>client</tt> sends a request <tt>reqenter</tt> and the others messages
					necessary to continue properly the entire workflow. Test is performed observing some significant
					resouces updated by <tt>parkingmanagerservice</tt> so as to verify the correct functioning of the
					system.
					<div class=remark2>
						<h3>1) At least a FREE SLOT, INDOOR-AREA FREE and OUTDOOR-AREA FREE</h3>
						<p>In this test is initially checked if value of <em>SLOTNUM</em> is greater than 0</p>
						<p>Subsequently the simulation is continued and controls that the value of the <em>RECEIPT</em> given from the system is greater than 10000.</p>
						<p>
							We want to check if, at the end of picking phase, the <em>CARSLOTNUM</em> value obtained from <tt>PICKUP</tt> request is greater than 0. 
						</p>

						<h3>2) At least a FREE SLOT, INDOOR-AREA NOT FREE and OUTDOOR-AREA NOT FREE</h3>
						<p>
							In this test at the start all the DOOR is occupied, so when the client send a <tt>reqenter</tt> request,
							so we want to check that the <em>SLOTNUM</em> value obtained as a <tt>waitIndoor</tt> reply, is greater than 0.
							After this control we set <em>INDOOR-AREA FREE</em>.
						</p>
						<p>
							At the end when client want to pickup his car have to wait until <em>OUTDOOR-AREA</em> becomes free. 
							When this happens the request is processed and <em>CARSLOTNUM</em> value is checked that it is greater than 0.
						</p>

						<h3>3) No FREE SLOT, INDOOR-AREA NOT FREE and OUTDOOR-AREA FREE</h3>
						<p>
							In this test there is not any free slot, so client must wait for at least one <em>parking slot</em> to become free. 
							It's then checked that during this waiting <b>Trolley</b> returning home.
						</p>
						<p>
							When a parking slot become free request is processed, but being <em>INDOOR-AREA NOT FREE</em>, 
							so we go to check that <em>SLOTNUM</em> obtained from <tt>waitIndoor</tt> is greater than 0.
						</p>
						<p>After those check simulation continue without problem and we are going to check if <em>RECEIPT</em> and <em>CARSLOTNUM</em> values are
						greater than 0.</p>

						<h3>4) Picking phase with invalid token - OUTDOOR-AREA FREE</h3>
						<p>
							In this test we want to check that after a bad <tt>pickup</tt> request sended by the client with a wrong value of the <em>TOKENID</em>,
							we check that <em>CARSLOTNUM</em> value is equals to -1.
						</p>
						<p>So client must send another <tt>pickup</tt> request with correct <em>TOKENID</em> value and we check that
							<em>CARSLOTNUM</em> is greater than 0.</p>

						<h3>5) Simultaneous arrival of more clients</h3>
						<p>
							In this test we want to check that request sended by two different clients will be processed in order of arrival. 
						</p>

					</div>

				<li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
					<br>
					Here it's tested the correct behaviour of <tt>thermometer</tt> and <tt>fan</tt>. During this
					kind of test, like in the <k>integration test</k>, the components updates some resouces whose values
					are observed and then checked.
					No tests are carried out on <b>outsonar</b> and <b>weightsensor</b> because they have already been tested in SPRINT 1.
					<div class=remark2>
						<h3>Testing the thermometer and fan</h3>
							It is tested that when the fan is not running all the values measured by the <b>thermometer</b> are increasing.<br>
							When the <b>fan</b> is running, it is checked that the temperature values decrease.
						

					</div>
			</ul>

		</p>

		<h2>Project</h2>
			We proceed by showing how the added components that allow the new features to work properly are implemented.<br>
			In particular we'll analyze the most relevant changes to existent QAktors, the new QAktor added to the system and
			some other components developed during SPRINT 2.
			<br><br>
			    <table style="width:100%">
            <tr>
                <td style="vertical-align:top; width:50%">
                    <center><b><u>CLIENT</u></b></center>
                    <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/src/parkingservice.qak">parkingservive.qak</a></center>
                    <pre>
State requestToEnter{
		[# var t = kotlin.random.Random.nextLong(2000,4000) #]
		[# delay(t) #]
		println("client notify his interest in entering | CLIENT")
		request parkingmanagerservice -m reqenter : reqenter(client)
	} Transition t0 
					whenReply waitIndoor -> noImmediatlyEntrystyle="vertical-align:top;
					whenReply slotsnum -> cartoindoor
	
	
	State noImmediatlyEntry{
		delay 3000
	} Goto cartoindoor
State afterslotnum {
	onMsg(slotsnum : slotsnum (SLOTNUM)){
		[# SLOTNUM = payloadArg(0).toInt()	#]
		println("SLOTNUM = $SLOTNUM | CLIENT" )
		request parkingmanagerservice -m carenter : carenter(V) 
	} 
} Goto cartoindoor
</pre>
<p>
	To <ks>requestToEnter</ks> state it's added a random delay in order to
	simulate clients arriving. This state, now, is able to handle also <tt>waitIndoor</tt>.
	In particular, if received, <b>client</b> performs a delay of 3 second to simulate the
	waiting before <em>INDOOR-area</em> become free and the move itself to <ks>cartoindoor</ks> state.
</p>
<pre>State pickupcar{
		delay 2000 //in 2 secondi porta via l'auto da OUTDOOR
		emit carwithdrawn : cw(bye)
		[# CLIENTDONE = CLIENTDONE + 1 #]
	} Goto stop if [# CLIENTDONE == 4 #] else requestToEnter 
	
	
	State stop{
		println("No more clients") 
	}</pre>
	<p>
		In this version, this state has a variable <k>CLIENTDONE</k> to count the numbers of simulated client, 
		that is incremented each time in which a <b>client</b> emits <tt>carwithdrawn </tt> event.
	</p>

<hr><hr>
		  <center><b><u>WEIGHTSENSOR</u></b></center>
		  <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/codedqak/weightsensorSimulator.kt">weightsensorSimulator.kt </a></center>

                
<pre>@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun simulateWeight(){
		    val w = Random.nextInt(750, 3000)
		    if(w>0)
				`it.unibo`.utils.ParkingSlotsKb.indoorFree  = false 
		     val m4 = MsgUtil.buildEvent(name, "weightsensor", "weight($w)")
		     emit(m4)
	}</pre>
	<p>
		A simple, but very important, changing made into <b>weightsensor</b> mock-Actor is
		that, starting from this version of system, it'll be this component that has the goal to
		set <em>INDOOR</em> area as occupied.
	</p>
	
<hr><hr>
		<center><b><u>OUTSONAR</u></b></center>
		 <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/codedqak/sonarSimulator.kt">sonarSimulator.kt </a></center>
		
<pre>@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun startSonar(){
			println("Occupied OUTDOOR, start SONAR | SONAR")
		 	`it.unibo`.utils.ParkingSlotsKb.outdoorFree  = false 
		 	mainScope = CoroutineScope(Dispatchers.Default)
		    startTimer()
		}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	  suspend fun stopSonar(){
			println("Free OUTDOOR | SONAR")
		 	`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true 
		    mainScope.cancel()
		    tmp = DTFREE
		}</pre>
		
		<p>
			Now, a similar task to <b>weightsensor</b> has also <b>outsonar</b>, that is
			setting the <em>OUTDOOR-area</em> satus as free or occupied. 
		</p>
		
				</td>
                <td style="width:50%">
					
                    <center><b><u>PARKINGMANAGERSERVICE</u></b></center>
                    <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/src/parkingservice.qak">parkingservive.qak</a></center>

<pre>
State s0 initial{
		[#
		outSonarActor     = sysUtil.getActor("outsonar")!!
		weightSensorActor = sysUtil.getActor("weightsensor")!!
		thermometerActor = sysUtil.getActor("thermometer")!!
		fanActor = sysUtil.getActor("fan")!!
		#]	
	forward thermometer -m startthermometer : thermometer(V)
	println("Park System START | SERVICE")
	}
	Transition t0
			whenTime 1000 -> check
	
	
	State check{
		delay 5000
	}
	Goto okReqenter if [#	`it.unibo`.utils.ParkingSlotsKb.checkSlots() > 0 #] 
		else checkOutdoor
		

	State okReqenter{
	} Goto ready if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree #] 
				else readyOnlyIndoor
				
	
	State checkOutdoor{
	}Goto readyOnlyOutdoor if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree #]
				else notReady
						
								
	State ready{
		println("INDOOR and OUTDOOR Avaiable | SERVICE")
	}Transition t0 
					whenTime 	5000	 -> moveToHome
					whenRequest reqenter -> acceptin
					whenMsg		pickup	 -> acceptout

				
				
	State readyOnlyIndoor{
		println("INDOOR Avaiable | SERVICE")
	}Transition t0
					whenTime 5000 		 -> moveToHome
					whenRequest reqenter -> acceptin
					

	State readyOnlyOutdoor{
		println("OUTDOOR Avaiable | SERVICE")
	}Transition t0
					whenTime 5000 		 -> moveToHome
					whenMsg		pickup	 -> acceptout
					
					
					
	State notReady{
	}Transition t0
					whenTime 5000 -> moveToHome
	
	
	State moveToHome{
		println("Moving Trolley to HOME")
		updateResource[# "toHome(V)" #]
		//move to Home [TODO: invia comando a trolley]
	} Goto check
</pre>
			<center><b><i>THERMOMETER TRIGGERING</i></b></center>
		<p>
			Into the <ks>s0</ks> state, <b>parkingmanagerservice</b> forward to <b>thermometer</b> actor a dispatch
			<tt>startthermometer</tt> to trigger it.
		</p>

		<center><b><i>CHECK STATE</i></b></center>
		<p>
			<b>parkingmanagerservice</b> before accept any kind of request from <b>client</b>, needs to check if all related
			conditions, cited into requirements, are satisfied.<br>
			According to which conditions are favorable, the FSM that describes the behavior of this actor, 
			moves itself to a different state and accepts different kind of requests:
			<ul>
			<li><ks>ready</ks>: It accepts both <tt>reqenter</tt> and <tt>reqpickup</tt>
			<li><ks>readyOnlyIndoor</ks>: It accepts only <tt>reqenter</tt>
			<li><ks>readyOnlyOutdoor</ks>: It accepts only <tt>pickup</tt> request.
			<li><ks>notReady</ks>: It cannot accept any kind of request, so it moves to <ks>moveToHome</ks> state after 5 seconds.
			</ul>
		</p>
		 
<pre>	State acceptin{
			[#
			SLOTNUM = `it.unibo`.utils.ParkingSlotsKb.findSlot()
			`it.unibo`.utils.ParkingSlotsKb.setSlot(SLOTNUM, false)
			#]
			//================[ acceptIN ]=====================	
			[# if(! `it.unibo`.utils.ParkingSlotsKb.indoorFree){ #]
				replyTo reqenter with waitIndoor : slotsnum ($SLOTNUM)
				updateResource [# "wait(${SLOTNUM}) " #]
			[# } #]
			[# else {#]
			updateResource [# "slotnum(${SLOTNUM}) " #]
			//================[ informIN ]=====================
			replyTo reqenter with slotsnum : slotsnum ($SLOTNUM)
			println("SLOTNUM = $SLOTNUM | SERVICE" )
			//================[ moveToIn ]=====================
			println("Trolley is moving to Indoor | SERVICE")
			[# } #]		
	} Transition t0
		whenRequest carenter -> carenter
					</pre>		 
		 
			<center><b><i>ELABORATION OF REQENTER</i></b></center>
			<p>
			Since the moment in which a <tt>reqenter</tt> is accepted, it's computed the
			<em>SLOTNUM</em> assigned to that <b>client</b>. Then if <em>INDOOR</em> area
			is free, the request is normally elaborated, otherwise it's sensend to <b>client</b>
			a reply <tt>waitIndoor</tt> with related assigned <em>SLOTNUM</em>, in order to notify him
			that it's necessary waiting that <em>INDOOR</em> area becomes available.<br>
			In any case, <b>parkingmanagerservice</b> expects to receive from <b>client</b>, sooner or later,
			a request <tt>carenter</tt> that notify its presence at <em>INDOOR</em>.
		 </p>
<pre>State acceptout{
	//===========[ acceptOUT / findSlot ]=====================
	onMsg (pickup : pickup(OUTDOORTOKEN)){
			[#  OUTDOORTOKEN = payloadArg(0).toString() #]
		}
	[#CARSLOTNUM = `it.unibo`.utils.ParkingSlotsKb.checkToken(OUTDOORTOKEN) #]
	updateResource [# "pickup($CARSLOTNUM)" #]
} Goto picking if [# CARSLOTNUM > 0 #] else tokenError</pre>
	
	<center><b><i>TOKEN CHECK</i></b></center>
	
	<p>
		When it's received a <tt>pickup</tt> request, it's immediately performed a checking
		of inserted token, in order to verify its authenticity and also to compute a parsing to
		obtain <em>CARSLOTNUM</em>. This is described more precisely below.
	</p>

<pre>[#`it.unibo`.utils.ParkingSlotsKb.setSlot(SLOTNUM, false)#]
[#`it.unibo`.utils.ParkingSlotsKb.setSlot(CARSLOTNUM, true)#]</pre>

	<center><b><i>STATUS SETTING OF PARKING SLOTS</i></b></center>
	
	<p>
		In states <ks>acceptin</ks> and <ks>picking</ks> are setted the value which represent
		the status of a certain <em>parking-slot</em>. This is possible thanks to a component that
		it'll be analyzed after.
	</p>
                </td>
            </tr>

        </table>
        <br>
        
        <p id="Intro to termo and fan" >
			It's also added two mock-actor <b>thermometer</b> and <b>fan</b>. They implem
        </p>

        <table>

            <tr>
                <td style="vertical-align:top;">
                    <center><b><u>THERMOMETER</u></b></center>
                    <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/codedqak/thermometerSimulator.kt">thermometerSimulator.kt</a></center>

<pre>const val maxTemp = 40
const val minTemp = 20
 
class thermometerSimulator (name : String ) : ActorBasic( name ) {
	
	var increment	= false
	var showing		= false
	var tempAtt = Temperature
	
	
	private var mainScope :CoroutineScope = CoroutineScope(Dispatchers.Default)
	//private val showScope = CoroutineScope(Dispatchers.Default)
	var job : Job? = null
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi		
override suspend fun actorBody(msg: ApplMessage) {
  	if( msg.msgId() == "startthermometer" &&  msg.msgType() == "dispatch") {
		tempAtt.setTemp(minTemp)
		increment	= true
		showing		= true
		startIncrement()
		showTemp()
	}else if(msg.msgId() == "stopinc" &&  msg.msgType() == "dispatch"){
		println("High temperature, stop inc process | THERMOMETER")
		increment	= false
		stopTherm()
	}else if(msg.msgId() == "normtemp" &&  msg.msgType() == "event"){
		println("Temperature is now ok, restart inc process | THERMOMETER")
		increment	= true
		startIncrement()
	}
 }
	
fun startIncrement(){
	println("Increment TEMP START | THERMOMETER")
	job = mainScope.launch{
		while(increment){
			delay(1000)
			tempAtt.incTemp()
			delay(3000)		
		}
	}
}
	
fun stopTherm(){
	job!!.cancel()
}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi	
	fun showTemp() {
		mainScope.launch{
			println("Show TEMP START | THERMOMETER")
			while(showing){
				var t = tempAtt.getTemp().toString()
				val m5 = MsgUtil.buildEvent(name, "temp", t)
				emit(m5)
				updateResourceRep( "temp($t)")
				delay(3000)
			}
		}
	}
}</pre>
<p>
	This is a new mock-actor, introduced from this SPRINT. It's simulate the behavior of a thermometer. It implements a funtion <i>startIncrement()</i>
	in which is lauched a <i>CoroutineScope</i> that invokes <a href="#temp_companion_obj">tempAtt.incTemp()</a> every period of time, in order to simulate temperature increasing.
	There is also another function that has simply the task of stopping this increasing, cancelling <i>CoroutineScope</i> launched previously.
	<br>
	It implements another funtion <i>showTemp()</i>, it also launches a <i>CoroutineScope</i> in order to emit an event <tt>temp</tt>, every period of time,
	cointainig the current temperature value.
	<br><br>
	At the starting of the system, <i>startIncrement()</i> it's launched after receiving <tt>startthermometer</tt> dispatch from <b>parkingmanagerservice</b>.
	This mock-actor is able to perceive also <tt>stopinc</tt> dispatch, sended from <b>fan</b> when maximum temperature is reached and <tt>normtemp</tt> event
	emitted from <b>fan</b> too, when temperature is came back under tollerance threshold.
	
</p>
<pre id="temp_companion_obj">
class Temperature(){
companion object temp{
	var tempAtt = 0
	@Synchronized fun incTemp(){
		tempAtt += 5
	}
	  
	@Synchronized fun decTemp(){
		tempAtt -= 5
    }

    @Synchronized fun getTemp(): Int {
		return this.tempAtt
	}
	@Synchronized fun setTemp(temp : Int) {
		tempAtt = temp
	}
}}</pre>
<p>
	Into the same file there is a <a href="https://blog.mindorks.com/companion-object-in-kotlin">companion object</a> which represents 
	the temperature resouce with some <i>synchronized</i> function to manipulate it.
	<ul>
		<li><i>tempAtt</i>, represents the current value of temperature,
		<li><i>incTemp()</i> increases <k>tempAtt</k> by 5,
		<li><i>decTemp()</i> decreases <k>tempAtt</k> by 5,
		<li><i>getTemp()</i> returns value of <k>tempAtt</k>,
		<li><i>setTemp(temp : Int)</i> sets a new value of <k>tempAtt</k>.
	</ul>
</p>
                </td>
                <td style="vertical-align:top;">
                    <center><b><u>FAN</u></b></center>
			<center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/codedqak/fanSimulator.kt">fanSimulator.kt</a></center>

<pre>class fanSimulator (name : String ) : ActorBasic( name ) {
	
	val tempAtt = Temperature
	var workFan = true
	
	val mainScope = CoroutineScope(Dispatchers.Default)
	val termSimulator = thermometerSimulator("")

@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
	override suspend fun actorBody(msg: ApplMessage) {
  		if( msg.msgId() == "temp" &&  msg.msgType() == "event") { 
			var temp = msg.msgContent().toInt()
			if(temp >= maxTemp){
				workFan = true
				startFan()
			}
		}
 	}
	
@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi
suspend fun startFan() {
	println("Fan START | FAN")
	updateResourceRep( "fan(ON)"  )
	forward("stopinc", "stopinc(temp)" ,"thermometer" ) 

	val job : Job = mainScope.launch{
			
		while(workFan){
			tempAtt.decTemp()
			if(tempAtt.getTemp() &lt= minTemp){
			  workFan = false
			  updateResourceRep( "fan(OFF)"  )
			  val m5 = MsgUtil.buildEvent(name, "normtemp", "norm(temp)")
			  emit(m5)
			}
			delay(3000)
		}	
	}
}}</pre>
<p>
	It's a mock-actor that simulate a cooler system equipped with a fan. <br>
	This actor perceives all <tt>temp</tt> events and checks temperature value: if it is over
	<k>maxTemp</k> value, <k>workFan</k> is setted TRUE and it' launched <i>startFan()</i> function.<br>
	In this function it's sended a dispatch <tt>stopinc</tt> to <b>thermometer</b> in order to stop temperature increasing simulation.
	Then it's launched a <i>CoroutineScope</i> in which it's performed a periodically decreasing of temperature, 
	using the <i>tempAtt.decTemp()</i> funtion of companion object.<br>
	When temperature value is under tollerance threshold, it's emitted <tt>normtemp</tt> event, that will be perceived by <b>thermometer</b>.
	
</p>
                </td>
            </tr>
            <tr>
                <td style="width:50%">
                    <center><b><u>PARKING SLOT KB</u></b></center>
                    <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/resources/it/unibo/utils/ParkingSlotsKb.kt">ParkingSlotsKb.kt</a></center>
                    <pre>object ParkingSlotsKb {
	
   private val charPool : List<Char> = ('0'..'5') + ('6'..'9')
	
   var slotsFree: BooleanArray = booleanArrayOf(true, true, true, true, true, true)
   var indoorFree = true
   var outdoorFree = true
   var numFreeSlots = 6
   var firstFreeSlot = 1
		
   init{
   	val fileName = "./tokens.txt"
	if(File(fileName).exists())
		File(fileName).delete() 
	else
		File(fileName)
   }
		
   fun setArea(s1:Boolean,s2:Boolean,s3:Boolean,s4:Boolean,s5:Boolean,s6:Boolean){
  	slotsFree = booleanArrayOf(s1,s2,s3,s4,s5,s6)
   }
	
   fun setSlot(slot : Int, v : Boolean) : Unit{
   	slotsFree.set(slot-1, v) 
   }
	</pre>
					<p>
						This file kotlin implements the knowledge base of parking area.
						We used an array of Boolean with six elements to represents status of parking slots.
						<ul>
						<li>Variables <k>indoorFree</k> and <k>outdoorFree</k> represent status of <em>INDOOR</em> and <em>OUTDOOR</em> area.<br>
						<li><k>numFreeSlots</k> it's the number of free slots, initially setted to 6.<br>
						<li><k>firstFreeSlot</k> represents first free slot to assign to client when parking is empty. <br>
						Into <k>init</k> block it's created a new <i>tokens.txt</i> file, in which it will stored all assigned <em>TOKENID</em> in order 
						to check their validity.<br>
						<li><i>setArea</i> is a function that simply set the status of each slot.<br>
						<li><i>setSlot</i> has the task to set a new value (<tt>true</tt> or <tt>false</tt>) to a certain slot.
						</ul>
                    </p>
                    <pre>fun findSlot() : Int{
		var i = 1
		for (v in slotsFree){
			if(v){
				firstFreeSlot = i
				return i
			}
			i++
		}
		return 0  
	}

 fun checkSlots() : Int{
		var i = 0	
		for (v in slotsFree){
			if(v){
				i++
			}	
		}
		numFreeSlots = i
		return i
	}</pre>
	
	<p>
		<ul>
			<li><i>findSlot()</i> return the number of first free slot found, searching starting from 1st to 6th.<br>If there is no free slot, it returns value 0.<br>
			Basically this is the function which computes <em>SLOTNUM</em>.
			<li><i>checkSlots()</i> returns the number of free slots into the parking area.
		</ul>
	</p>
	
<pre>fun generateToken(slot : Int) : String {
	val psw = (1..4)
		.map { _ -> kotlin.random.Random.nextInt(0, charPool.size) }
		.map(charPool::get)
		.joinToString("");
	val Token = slot.toString() + psw
	write(Token)
	return Token
}
	
fun checkToken(token : String) : Int {
	var slotnum = -1
	val fileName = "./tokens.txt"
	var myfile = File(fileName)
	var newFile: String = ""
	val lines: List<String> = myfile.readLines()
	lines.forEach{		
			if(it==token)
				slotnum = token.substring(0,1).toInt()
			else
				newFile = newFile+ it +"\n"	
	}
	myfile.delete()
	myfile = File(fileName)
	myfile.appendText(newFile)
	return slotnum
}
		
fun write(token : String){
	val fileName = "./tokens.txt"
	val myfile = File(fileName)
	myfile.appendText(token+"\n")
	}</pre>
	
	<p>
		<ul>
			<li><i>generateToken</i> it's the function which computes effectively <em>TOKENID</em> starting from provided <em>SLOTNUM</em>.<br>
			In particular, it generates a 5 digits token, where first number is the related <em>SLOTNUM</em>, while next 4 digits represent
			a random code, that has the task to avoid the ability to create fake tokens.<br>
			Obviously, safety of this solution it's not optimal, but it's only a representative implementation, because it will be possible, in the future,
			to increase the number of digits or the complexity of security code computaion.
			<li><i>checkToken</i> performs a verification of inserted <em>TOKENID</em> and if checking is successful it returns related <em>SLOTNUM</em>.<br>
			Verification it's performed scrolling the list of tokens, stored in <i>tokens.txt</i>, and checking if provided token is present into the list.
			If current token is valid, it is removed from the list.
			<li><i>write</i> simply it's used into <i>generateToken</i> function to add a <i>TOKENID</i> into the <i>tokens.txt</i> file.
		</ul>
	</p>

                </td>
                <td style="vertical-align: text-top">
                    <center><b><u>ANOTHER TESTING TOOL</u></b></center>
                    <center><a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_2/it.unibo.ParkManagerService_s2/ClientGUIsimulator.ipynb">ClientGUIsimulator.ipynb</a></center>
                    
					<p>
						In this SPRINT it's introduced an additional tool to perform manual testing. In particular it's a <i>.ipynb</i> file that can be
						executed using <a href="https://jupyter.org/">Jupyter Notebook</a>.<br>
						In this way it's possible send requests to the system even without having yet a GUI.
					</p>
					<pre>
port = 5683
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

reqenter      = "msg(reqenter,request,pyclient,parkingmanagerservice,reqenter(client),1)"
carenter      = "msg(carenter,request,pyclient,parkingmanagerservice,movetoin(ok),2)"
pickup        = "msg(pickup,dispatch,pyclient,parkingmanagerservice,pickup(VALUE),3)"
carwithdrawn  = "msg(carwithdrawn,event,pyclient,none,cw(ok),4)"


def connect(port) :
    server_address = ('localhost', port)     
    sock.connect(server_address)    
    print("CONNECTED " , server_address)

def emit( event ) :
    print("emit ", event)
    msg = event + "\n"
    byt=msg.encode()    
    sock.send(byt)
    
def forward( message ) :
    print("forward ", message)
    msg = message + "\n"
    byt=msg.encode()   
    sock.send(byt)

def request( message ) :
    print("request ", message)
    msg = message + "\n"
    byt=msg.encode()  
    sock.send(byt)
    handleAnswer()

def handleAnswer() :
    print("handleAnswer " )
    while True: 
        reply = ''
        while True:
            answer = sock.recv(50)
            if len(answer) &lt= 0 :
                break
            reply += answer.decode("utf-8")
            if reply.endswith("\n") :
                break
        print("reply=", reply)
        break
					</pre>
					<p>
						This python script opena a WebSocket on the port <tt>5683</tt>, where is runned our the system.<br>
						There are four strings, which simulate the messages that can be send from GUI to system, they are written in according of <a>ApplMessage</a> synstax.
						<ul>
						<li><i>emit</i> sends, via socket, to the system a message, that in this case should be an <tt>event</tt>
						<li><i>forward</i>sends, via socket, to the system the message passed like argument, that in this case should be a <tt>dispatch</tt>
						<li><i>request</i> send to the system a <tt>request</tt> message and then launches <i>handleAnswer</i> function, which performs an active waiting until a
							<tt>reply</tt> is received.
						</ul>
					</p>
					<pre>def console() :  
    v =  str( input() )
    print("INPUT" , v  )    
    while( v != "q"  ) :
        if v=="1": request(reqenter)
        if v=="2": request(carenter)
        if v=="3": 
            c = str( input() )
            forward(pickup.replace("VALUE",c))
        if v=="4": emit(carwithdrawn)
        v = str(input())   
        </pre>
        <p>
			<i>console()</i> is the function that allow the user to enter into a textbox the input, on which it depends which message the <b>client</b> will send.<br>
			The possible input are <k>1</k>, <k>2</k>, <k>3</k> or <k>4</k>, each of them corresponds to a different action of the <b>client</b>.
        </p>
                </td>
            </tr>
        </table>
			
			
		<h2>Testing</h2>
		<a href="../test/it/unibo/parkingmanagerservicetest/TestPlan.kt">TestPlan.kt </a><br>
		<p>Tests is built using CoapObserver provided by the costumer in the project <ks>it.unibo.qak21.basicrobot
				</ks> (<a
					href="../test/it/unibo/parkingmanagerservice/test/utils/CoapObserverForTesting.kt">CoapObserverForTesting.kt</a>).
				<br>
		</p>
		<br>
		<kc>TestPlans goals:</kc>
			<ul>
				<li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b>
					</k>. <br> <br>
					In this testing plan are employed <tt>parkingmanagerservice</tt> and <tt>client</tt>. In particular,
					to start system simulation <tt>client</tt> sends a request <tt>reqenter</tt> and the others messages
					necessary to continue properly the entire workflow. Test is performed observing some significant
					resouces updated by <tt>parkingmanagerservice</tt> so as to verify the correct functioning of the
					system.
					<div class=remark2>
						<h3>1) At least a FREE SLOT, INDOOR-AREA FREE and OUTDOOR-AREA FREE</h3>
						<p>In this test is initially checked if value of <em>SLOTNUM</em> is greater than 0.</p>
						<p>Subsequently the simulation is continued and controls that the value of the <em>RECEIPT</em> given from the system is greater than 10000.</p>
						<p>
							We want to check if, at the end of picking phase, the <em>CARSLOTNUM</em> value obtained starting from <tt>pickup</tt> request is greater than 0. 
						</p>
						<table>
						<tr>
							<td style="width:50%">
						<pre>@Test
@kotlinx.coroutines.ObsoleteCoroutinesApi
fun testWorkflow(){
	//=============================== SETUP =================================
	`it.unibo`.utils.ParkingSlotsKb.setArea(false,false,false,false,true,false)
	`it.unibo`.utils.ParkingSlotsKb.indoorFree  = true
	`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true
	//========================================================================
	runBlocking{
		val channelForObserver = Channel<String>()
		testingObserver!!.addObserver(channelForObserver, "slotnum")
		clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")
		
		println("+++++++++ testreqenter ")	
		
		var result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum > 0)
		
		delay(2000)

		testingObserver!!.addObserver(channelForObserver, "receipt")
		clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")
			
		println("+++++++++ testcarenter")	
		result = channelForObserver.receive()
		token = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token > 10000)
			
		delay(4000)
			
		testingObserver!!.addObserver(channelForObserver!!, "pickup")
		clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")
		println("+++++++++ testpickup")
		result = channelForObserver.receive()
		println("+++++++++ testpickup RESULT=$result +++++++++")
		assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() > 0) 			
  	}
}</pre>
		</td>
		<td>
		<p>
			Test starts with a setup phase, in which is setted the system with required condition to perfoming current test.<br>
			Are observed three different resources <tt>slotnum</tt>, <tt>receipt</tt> and <tt>pickup</tt>.
			Are simulated, sequentially, the sending of a <tt>reqenter</tt>, a <tt>carenter</tt> and a <tt>pikcup</tt>.<br>
			Then the value of resources updated by the system are checked.
		</p>
		</td>
 	</tr>
 	</table>
						
						<h3>2) At least a FREE SLOT, INDOOR-AREA NOT FREE and OUTDOOR-AREA NOT FREE</h3>
						<p>
							In this test, at the start of the system, both <em>INDOOR</em> and <em>OUTDOOR</em> are occupied.
							When the <b>client</b> sends a <tt>reqenter</tt>, we want to check that the <em>SLOTNUM</em> value obtained from <tt>waitIndoor</tt> reply, is greater than 0.
							After this control <em>INDOOR-AREA</em>em> is setted at FREE, simulating that a parking operation is gone well.
						</p>
						<p>
							After that, <b>client</b> sends a <tt>carenter</tt> request because now <em>INDOOR</em> is FREE, and he receives his <em>TOKENID</em>.
						</p>
						<p>
							After a certain period of time, <b>client</b> wants to pickup his car and so send <tt>pickup(TOKENID)</tt> dispatch while <em>OUTDOOR</em>
							is OCCUPIED. After 3 seconds <em>OUTDOOR</em> is setted to FREE, and, if the system works well, client's pickup request is elaborated.
						</p>
						
						<table>
						<tr>
							<td>
							<pre>//@Test
 @kotlinx.coroutines.ObsoleteCoroutinesApi
fun testWorkflow2(){
	
	`it.unibo`.utils.ParkingSlotsKb.setArea(false,false,false,true,true,false)
	`it.unibo`.utils.ParkingSlotsKb.indoorFree  = false
	`it.unibo`.utils.ParkingSlotsKb.outdoorFree  = false

	runBlocking{
		
		val channelForObserver = Channel<String>()
		
		testingObserver!!.addObserver(channelForObserver, "wait")
		clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")
		
		println("+++++++++ testreqenter ")	
		var result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum > 0)
		
		`it.unibo`.utils.ParkingSlotsKb.setSlot(4, false)
		`it.unibo`.utils.ParkingSlotsKb.indoorFree  = true
		
		delay(3000)
					
		testingObserver!!.addObserver(channelForObserver, "receipt")
		clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")
			
		println("+++++++++ testcarenter")	
		result = channelForObserver.receive()
		token = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token > 10000)
		
		delay(3000)
		testingObserver!!.addObserver(channelForObserver, "pickup")
		clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")
		
		delay(3000)
			
		`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true
			
		println("+++++++++ testpickup")
		result = channelForObserver.receive()
		println("+++++++++ testpickup RESULT=$result +++++++++")
		assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() > 0)
			
		delay(2000)
			
		clientactor!!.emit(MsgUtil.buildEvent("client", "carwidrawn","cw(taken)"))
	}
}</pre>
							</td>
							<td>
								<p>
									Like previous test, are used 3 observers for 3 resources updated by the system after elaborating respectively <tt>waitIndoor</tt>,
									<tt>carenter</tt> and <tt>pickup</tt> requests.<br>
									Are added some delays to simulate the time needed for the <em>INDOOR</em> or <em>OUTDOOR</em> to become FREE.
								</p>
							</td>
						</tr>
						</table>

						<h3>3) No FREE SLOT, INDOOR-AREA NOT FREE and OUTDOOR-AREA FREE</h3>
						<p>
							In this test there is not any free slot, so client must wait for at least one <em>parking slot</em> to become free. 
							It's then checked that during this waiting <b>Trolley</b> returning home.
						</p>
						<p>
							When a parking slot become free request is processed, but being <em>INDOOR-AREA NOT FREE</em>, 
							so we go to check that <em>SLOTNUM</em> obtained from <tt>waitIndoor</tt> is greater than 0.
						</p>
						<p>After that, simulation continues without problem and we check if provided <em>TOKENID</em> is greater then 10000 and if <em>CARSLOTNUM</em> value is
						greater than 0.</p>
						<table>
						<tr>
							<td>
						<pre>@kotlinx.coroutines.ObsoleteCoroutinesApi
fun testWorkflow3(){
		
	`it.unibo`.utils.ParkingSlotsKb.setArea(false,false,false,false,false,false)
	`it.unibo`.utils.ParkingSlotsKb.indoorFree  = false
	`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true

	runBlocking{
		
		val channelForObserver = Channel<String>()
		
		testingObserver!!.addObserver(channelForObserver, "toHome")
		clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")
		
		println("+++++++++ testNotFreeSlot ")	
		var result = channelForObserver.receive()
		println("+++++++++ testNotFreeSlot RESULT=$result +++++++++")
		assertEquals(result, "toHome(V)")
		
		`it.unibo`.utils.ParkingSlotsKb.setSlot(4, true)
		println("One free slot")
		
		delay(1000)
		
		println("+++++++++ testreqenter ")	
		testingObserver!!.addObserver(channelForObserver, "wait")
		clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")
		
		result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum > 0)
		
		`it.unibo`.utils.ParkingSlotsKb.indoorFree = true
		
		delay(1000)
		
		testingObserver!!.addObserver(channelForObserver, "receipt")
		clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")
		
		println("+++++++++ testcarenter")
		result = channelForObserver.receive()
		token = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token > 10000)
		
		delay(1000)
		
		testingObserver!!.addObserver(channelForObserver, "pickup")
		clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")
		
		delay(500)
		
		println("+++++++++ testpickup")
		result = channelForObserver.receive()
		println("+++++++++ testpickup RESULT=$result +++++++++")
		assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() > 0)
		}
	}</pre>
		</td>
		<td>
			<p>
				In this test are observed the same resources of previous test and one more <tt>toHome</tt>, bacause this test starts in the conditions of
				the system have no free slot. So the system goes into the status <ks>toHome</ks>, in which is commanded to <b>Trolley</b> to move toward his HOME.
				In this state it's also updated <tt>toHome</tt> resouce, in order to test this behavior of system.<br>
				After that, it's simulated that a <b>client</b> wants to enter into parking and he sends <tt>reqenter</tt>, but the system will not elaborate it immediately
				because there are no free slot. After some seconds a parking slot is setted to FREE and <tt>reqenter</tt> is elaborated by system, that reply to <b>client</b>
				with a <tt>waitIndoor</tt>.<br>
				After a certain period of time, <em>INDOOR</em> is setted to FREE and the operation of parking, and after, of picking proceed normally, checking ever if
				provided <em>TOKENID</em> is greater then 10000 and if <em>CARSLOTNUM</em> value is greater than 0.</p>
			</p>
		</td>
	</tr>
	</table>
					
						<h3>4) Picking phase with invalid token - OUTDOOR-AREA FREE</h3>
						<p>
							In this test we want to check that, after entering an invalid <em>TOKENID</em> by <b>client</b>, the value of <em>CARSLOTNUM</em> will be equals to -1.
						</p>
						<p>So client must send another <tt>pickup</tt> request with correct <em>TOKENID</em> value, then we'll check that <em>CARSLOTNUM</em> will be greater than 0.</p>
						<table>
							<tr>
								<td>
								<pre>@Test
 @kotlinx.coroutines.ObsoleteCoroutinesApi
fun testWorkflow4(){
	
	`it.unibo`.utils.ParkingSlotsKb.setArea(false,false,false,true,false,false)
	`it.unibo`.utils.ParkingSlotsKb.indoorFree  = true
	`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true

	runBlocking{
		
		val channelForObserver = Channel<String>()
		
		testingObserver!!.addObserver(channelForObserver, "slotnum")
		clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")			
	
		println("+++++++++ testreqenter ")	
		
		var result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum > 0)
			
		delay(2000)
			
		testingObserver!!.addObserver(channelForObserver, "receipt")
		clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")
			
		println("+++++++++ testcarenter")	
		result = channelForObserver.receive()
		token = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token > 10000)
			
		delay(1000)
		
		testingObserver!!.addObserver(channelForObserver, "pickup")			
		clientactor!!.forward("pickup","pickup(12345)","parkingmanagerservice")
			
		delay(500)			
			
		println("+++++++++ testpickupError")
		result = channelForObserver.receive()
		println("+++++++++ testpickupError RESULT=$result +++++++++")
		assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() &lt 0)
			
		delay(1000)

		clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")
			
		delay(500)
			
		println("+++++++++ testpickupCorrect")
		result = channelForObserver.receive()
		println("+++++++++ testpickupCorrect RESULT=$result +++++++++")
		assertTrue(result.substringAfter("(",result).substringBefore(")",result).toInt() > 0)
 			
  	}
}</pre>
								</td>
								<td>
									<p>
										In this test, it's performed a standard parking operation with sending of <tt>reqenter</tt> and <tt>carenter</tt> and receiving related
										replies. But in this case it's simulate that <b>client</b> sends an invalid <em>TOKENID</em> during picking phase and we check that the 
										computed <em>CARSLOTNUM</em> is equals to -1. It's also checked thatif <b>client</b> enter a valid <em>TOKENID</em>, picking operation
										will go well.
									</p>
								</td>
							</tr>
						</table>
						<h3>5) Simultaneous arrival of more clients</h3>
						<p>
							In this test we want to check that request sended by two different clients will be processed in order of arrival. 
						</p>
						<table>
						<tr>
						<td>
							<pre>@Test
@kotlinx.coroutines.ObsoleteCoroutinesApi
fun testWorkflow5(){
		
	`it.unibo`.utils.ParkingSlotsKb.setArea(true,true,true,true,true,true)
	`it.unibo`.utils.ParkingSlotsKb.indoorFree  = true
	`it.unibo`.utils.ParkingSlotsKb.outdoorFree  = true
		
	runBlocking{
			
		val channelForObserver = Channel<String>()
			
		testingObserver!!.addObserver(channelForObserver, "slotnum")
			
		var msg = MsgUtil.buildRequest("client1", "reqenter","reqenter(bob)","parkingmanagerservice")
		MsgUtil.sendMsg(msg,myactor!!)
		msg = MsgUtil.buildRequest("client2", "reqenter","reqenter(george)","parkingmanagerservice")
		MsgUtil.sendMsg(msg,myactor!!)

		println("+++++++++ testreqenter1 ")	
			
		var result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		slotnum = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum > 0)
		
		delay(2000)
			
		testingObserver!!.addObserver(channelForObserver, "receipt")
			
		msg = MsgUtil.buildRequest("client1", "carenter","carenter(bob)","parkingmanagerservice")
		MsgUtil.sendMsg(msg,myactor!!)
		println("+++++++++ testcarenter1")	
		result = channelForObserver.receive()
		token = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token > 10000)
			
		delay(1000)
		
		println("+++++++++ testreqenter2")	
			
		result = channelForObserver.receive()
		println("+++++++++ testreqenter RESULT=$result +++++++++")
		var slotnum2 = result.substringAfter("(",result).substringBefore(")",result).toInt()
		assertTrue(slotnum2 > 0 && !slotnum2.equals(slotnum))
			
		delay(2000)
		
		testingObserver!!.addObserver(channelForObserver, "receipt")
			
		msg = MsgUtil.buildRequest("client2", "carenter","carenter(george)","parkingmanagerservice")
		MsgUtil.sendMsg(msg,myactor!!)
		println("+++++++++ testcarenter2")	
		result = channelForObserver.receive()
		var token2 = result.substringAfter("(",result).substringBefore(")",result).toInt()
		println("+++++++++ testcarenter RESULT=$result +++++++++")
		assertTrue(token2 > 10000 && !token2.equals(token))
  	}
}
	</pre>
						</td>
						<td>
							<p>
								In this test are deploy two actors which simulate two <b>clients</b>, they sends a <tt>reqenter</tt> almost togheter. 
								<br>[...]
							</p>
						</td>
						</tr>
						</table>

					</div>

				<li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
					<br>
					Here it's tested the correct behaviour of <tt>thermometer</tt> and <tt>fan</tt>. During this
					kind of test, like in the <k>integration test</k>, the components updates some resouces whose values
					are observed and then checked.
					No tests are carried out on <b>outsonar</b> and <b>weightsensor</b> because they have already been tested in SPRINT 1.
					<div class=remark2>
						<h3>Testing the thermometer and fan</h3>
							It is tested that when the fan is not running all the values measured by the <b>thermometer</b> are increasing.<br>
							When the <b>fan</b> is running, it is checked that the temperature values decrease.
						
					<table>
						<tr>
							<td>
								<pre>Unit Testing: FAN, THERMOMETER
============================*/	
	//@Test
	fun testThermometerAndFan(){
		`it.unibo`.utils.ParkingSlotsKb.setArea(true,true,true,true,true,true)
 		`it.unibo`.utils.ParkingSlotsKb.indoorFree   = true
		`it.unibo`.utils.ParkingSlotsKb.outdoorFree  = true
		
		runBlocking{
			
			val channelForUnitTesting = Channel<String>()
			testingObserver!!.addObserver(channelForUnitTesting, "null")
			var result = ""
			
			val thermoObs = CoapObserverForTesting("obsthermometer","ctxparkingservice", "thermometer", "5683")
			val fanObs = CoapObserverForTesting("obsfan","ctxparkingservice", "fan", "5683")
			thermoObs!!.addObserver(channelForUnitTesting, "temp")
			fanObs!!.addObserver(channelForUnitTesting, "fan")
			
			var fanON = false
			var tmp   = 0
			while(!fanON){
				result = channelForUnitTesting.receive()
				println("result = $result")
				if(result != "fan(ON)"){
					var temperature = 
						result.substringAfter("(",result).substringBefore(")",result).toInt()
					assertTrue(temperature >= tmp)
					tmp = temperature
					delay(1000)
				}
				else{
					fanON = true
				}
			}
			while(fanON){
				result = channelForUnitTesting.receive()
				println("result = $result")
				if(result != "fan(OFF)"){
					var temperature = 
						result.substringAfter("(",result).substringBefore(")",result).toInt()
					assertTrue(temperature &lt= tmp)
					tmp = temperature
					delay(1000)
				}
				else{
					fanON = false
				}
			}
			
		}</pre>
							</td>
							<td>
								<p>
									In this test plan, two morw observers are added:<br>
									<b>thermoObs</b> and <b>fanObs</b>. In this test, the initial condition are:
									<ul>
										<li>temp = 0C
										<li>fan  = OFF
									</ul>
									The test consists in increasing gradually the temperature and verify if the 
									temperature increases correcly until cooler system starts it-self. The it's verified if
									the temperature decreasing correcly until fan goes OFF.
								</p>
							</td>
						</tr>
					</table>
					
					</div>
			</ul>

		</p>
		
		
		<h2>Deployment</h2>
		The deployment of SPRINT 2 consists in a release on a <a
			href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_2">Github repository</a>.

		<h2>Maintenance</h2>
		This is the second SPRINT, more features will be released in the next (third) SPRINT.
		<br /><br />
	</div>

	<div style="background-color:rgba(42, 7, 241, 1.0); width:100%;text-align:center;color:white">
		<table style="width:100%" border="1">
			<tr>
				By Mantovani Leonardo and Pier Domenico d'Amicis

			</tr>
		</table>
	</div>
</body>

</html>
