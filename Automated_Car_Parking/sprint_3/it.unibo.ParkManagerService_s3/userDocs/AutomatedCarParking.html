<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
	body {
		margin-left: 30px;
		margin-right: 30px;
	}

	;

	P {
		font-family: Tahoma;
		font-size: 10pt;
	}

	;

	a,
	a:visited,
	a:active,
	a:link,
	a:hover {
		text-decoration: underline;
		color: #545454;
		background-color: transparent;
		font-size: 93%;
	}

	a:hover {
		background-color: #cccccc;
	}


	hr {
		clear: both;
		height: 1px;
		color: #242424;
		background-color: transparent;
	}

	h1,
	h2,
	h3 {
		color: #242424;
		clear: left;
		font: 100% Tahoma, Helvetica, Arial, sans-serif;
		margin-bottom: 0.5em;
		padding-top: 0.5em;
		border-radius: 10px;
		padding: 5px;
	}

	top {
		width: 100%;
	}


	#i {
		color: #ff1010;
	}

	tt {
		font-family: "Arial";
		font-size: 90%;
		color: #006600;
	}

	div.remark2 {
		background-color: #F5F5DC;
		border: 1.5px solid #d5f2ed;
		padding: 15px;
		margin: 10px;
		border-radius: 25px;
	}


	em {
		font-family: "Arial";
		font-size: 80%;
		font-weight: bold;
		border-style: solid;
		border-color: #abe876;
		color: #1632cc;
	}

	bc {
		font-family: "Arial";
		font-size: 90%;
		font-weight: bold;
		color: #990000;
		background-color: #fcf8c7;
	}

	ks {
		font-family: "Arial";
		font-weight: bold;
		color: #0000CD;
		font-size: 90%;
	}

	kc {
		font-family: "Arial";
		font-weight: bold;
		color: #008000;
		font-size: 90%;
	}

	pre {
		font-family: "Consolas";
		font-size: 85%;
		background-color: #f5f5f5;
		border: 1.5px solid silver;
		padding: 5px;
	}

	m {
		font-family: "Helvetica";
		line-height: 100%;
		font-size: 75%;
	}

	div.body {

		font-size: 18px;
	}

	k {
		color: #990000;
		font-weight: bold;
		font-size: 90%;
	}

	h1 {
		font-size: 150%;
		background-color: #b2c0ff;
		padding: 10px;
	}

	h2 {
		background-color: #9ed8ff;
		font-size: 130%;
	}

	h3 {
		background-color: #e6ccff;
		font-size: 100%;
	}

	h4 {
		background-color: #ccffcc;
		font-size: 100%;
		width: 95%;
		border-radius: 5px;
		padding: 2px;
	}

	h5 {
		background-color: #d5ffb0;
		font-size: 100%;

	}

	div.req {
		background-color: #d9ffb3;
		font-size: 18px;
		width: 700px;
		border: 3px solid green;
		padding: 15px;
		margin: 10px;
	}

	div.remark {
		background-color: #E3F2FD;
		border: 1.5px solid #d5f2ed;
		padding: 15px;
		margin: 10px;
		border-radius: 25px;
	}

	table,
	th,
	td {
		border: 1px solid black;
		border-collapse: collapse;
	}

	ol,
	ul,
	li {
		margin: 0;
		margin-left: 10px;
		padding: 0;
		padding-bottom: 5px;
	}

	table,
	th,
	td {
		border: 1px solid black;
	}

	img {
		border: 1.5px solid #d5f2ed
	}

	a,
	a:visited,
	a:active,
	a:link,
	a:hover {
		text-decoration: underline;
		color: #545454;
		background-color: transparent;
	}

	div.wrapdesc {
		width: 90%;
		margin: auto;
	}

	div.imagedesc {
		width: 85%;
		margin: auto;
	}
</style>

<head>

	<title>AutomatedCarParking</title>
</head>

<body>
	<div id="top">
		<h1>
			<font size="5">Automated Car-Parking</font>
		</h1>
	</div>

	<div class="body">
		<h2><a name="introduction"></a>Introduction - SPRINT 3</h2>
		<div class="remark">
			<p>In this document it will be analysed the third SPRINT of the project.
				In this phase we will extend previous SPRINT's model, adding the implementation of an virtual <k>trolley</k> that performs the movements during the parking and picking phases.
			</p>
			<p>
				Link to <a href="https://htmlpreview.github.io/?https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_1/it.unibo.ParkManagerService_s1/userDocs/AutomatedCarParking.html">SPRINT 2</a>
			</p>
		</div>

		<h2>Problem analysis</h2>
		<div class="remark">
			<p>As mentioned in the <a href="#introduction">Introduction</a> in this SPRINT, we will analyze a simplified
        version (with less functionality) of the final system.</p>
				<p>
					<h3>Assumptions</h3>

					In this version are applied the simplifications below:
					<br><br>
					<ul>
						<li>no <k>GUI</k> will be implemented (neither for the client nor for the parking-manager);
							<div class="remark2" ;>GUIs will not be implemented because, during these early stages of
								project development, we will only carry out local tests. </div>
								
						<li>Actions of <k>Parking-Manager</k> will not be performed;
							<div class="remark2">The manager performs its actions through the GUI, as it is not implemented
								it cannot perform operations either</div>

						<li>
							<k>Outsonar</k> and <k>WeightSensor</k> are components simulated by a software;
							<div class=remark2>These sensors are simulated because they are not yet physically available.
								It is possible that real <b>outsonar</b> will be used in future SPRINTs.</div>

						<!--<li>
							<k>Thermometer</k> and <k>fan</k> are components simulated by a software. Reaching the
							maximum temperature does not allow the Parking Manager (which is not yet considered) to stop
							the Trolley
							<div class=remark2>Since neither <tt>Trolley</tt> and <tt>Parking Manager</tt> are not yet
								considered, when the maximum temperature si reached no action will be performed.
								Activation of <k>fan</k> will be automatized.</div>


						<li>The alarm that is emmited if <k>outsonar timer</k> expires does not causes any action;
							<div class=remark2>
								The alarm is not handled at software level, no actions will be performed.
							</div>-->

					</ul>
				</p>

				<h3>Model - SPRINT 3</h3>
			
				<br>
				<table style="width:100%; border:1px solid; font-family: Consolas; background-color:#f5f5f5;">
					<tr>
						<td>
							<center>
								<ks>parkingmanagerservice</ks>
							</center>
						</td>
						<td>
							<center>
								<ks>client</ks>
							</center>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<center>
								<bc>Parking Phase</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td style="width:50%">
							<br>
							<ul style="font-family: Consolas; font-size: 15px">
								<li>It checks if there is at least one <tt>parking-slot</tt> available.
                  
								<li>After this check it is determined if <tt>reqenter</tt> can be accepted.
                  
								<li>It's received the request <tt>reqenter</tt> sended by a <b>client</b>.</li>
                
                <li><ks>[acceptIN]</ks> It's generated <em>SLOTNUM</em> and the related slot is marked as occupied.
								
                <li><ks>[informIN]</ks> If <em>INDOOR-area</em> is <i>FREE</i> and trolley status is not <i>STOPPED</i> the request is immediately elaborated sending to <b>client</b> the reply
                  <tt>slotsnum : slotsnum ($SLOTNUM)</tt>. Otherwise it's sended to <b>client</b> the reply <tt>waitIndoor : slotsnum ($SLOTNUM)</tt>, and so <b>client</b> 
                  waits until the <em>INDOOR-area</em> become FREE or trolley status is not STOPPED.							
								
								<li>It's received the request <tt>carenter</tt> sended by the <b>client</b>.
                  
                <li><b>parkingmanagerservive</b> emits an event <tt>carindoorarrival</tt>, to notify that	the client's car is in <em>INDOOR-area</em>.  
								
                <li><ks>[moveToIn]</ks> Commands are sent to the <b>trolley</b> so that it performs the movements to go from its current position to <em>INDOOR</em>
                  
                <li>The <b>weightsensor</b> perceives <tt>carindoorarrival</tt> and emit the event <tt>weight(CARWEIGHT)</tt>.
                  
                <li><em>INDOOR</em> is marked as occupied.  
                  
                <li> It's expected the event <tt>finished</tt> emitted by <b>trolley</b> at the end of his path.
								
								<li> <ks>[receipt]</ks> It's generated the <em>TOKENID</em> related to <em>SLOTNUM</em> assigned to <b>client</b> and reply to him with <tt>receipt(TOKENID)</tt>.
								
                <li> <ks>[moveToSlotIn]</ks> If <b>trolley</b> is in <em>INDOOR-area</em>, <b>Trolley</b> takes the car and moves it to slot assigned to it.
                  
                <li>When event <tt>finished</tt> is perceived, <em>INDOOR</em> is marked as free.
								
                <li><ks>[moveToHome]</ks> If for a while no requests are received, commands are sent to the <b>trolley</b> for return to <em>HOME</em>.
                  
                <li> If a new request arrives during returnig to <em>HOME</em>, it must be immediately handled.
                  
							</ul>
              
						<td>
              
							<ul style="font-family: Consolas; font-size: 15px">
								<li><b>client</b> sends a request <tt>reqenter</tt> to notify his interest in
									entering his car in the <em>parking-area</em>.
								<li>If <em>SLOTNUM > 0</em> and <em>INDOOR-area</em> is FREE, <b>client</b> moves the car in front of <em>INDOOR</em>,
									(press the <em>CARENTER</em> button) and send the request <tt>carenter</tt> to <b>parkingmanagerservive</b>, otherwise
									<b>client</b> waits for the <em>INDOOR-area</em> to become FREE.
							</ul>
						</td>
					<tr>
						<td colspan=2>
							<center>
								<bc>Car pick up phase</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td>
							<ul style="font-family: Consolas; font-size: 15px">
                
								<li>It checks if <em>OUTDOOR</em> is FREE and if trolley status is not STOPPED.
                  
								<li>After the checks it is determined if <tt>pickup</tt> can be elaborated.
                  
								<li> <ks>[acceptOUT]</ks> It's received the dispatch <tt>pickup(TOKENID)</tt> sended by a <b>client</b>.
                  
								<li> <ks>[findSlot]</ks> It's obtained the <em>CARSLOTNUM</em> from <tt>TOKENID</tt> sended by <b>client</b>.
                  
                <li> <ks>[moveToSlotOut]</ks> Commands are sent to the <b>trolley</b> so that it performs the movements to go from the current position to <em>CARSLOTNUM</em>.
                  
                <li>The slot corrisponding to <em>CARSLOTNUM</em> is marked as free.
                  
                <li> <ks>[moveToOut]</ks> When it's perceives event <tt>finished</tt> and it's verified that <b>trolley</b> is in <em>CARSLOTNUM</em>, are sent commands to the <b>trolley</b> 
                  so that it performs the movements to go from <em>CARSLOTNUM</em> to <em>OUTDOOR</em>. 
                  
                <li><b>parkingmanagerservice</b> emits an event <tt>caroutdoorarrival</tt>
           
                <li>The <b>ousonar</b> perceives <tt>caroutdoorarrival</tt> and actives itself and its internal timer and <em>OUTDOOR</em> is marked as occupied.
								
                <li>Timer of <b>outsonar</b> will be cancel when the <b>client</b> emits the event <tt>carwithdrawn</tt>.
                  
								<li>If timer (set to <tt>DTFREE</tt>) expires, <b>outsonar</b> emit an event <tt>timeout</tt>.
                  
								<li><ks>[moveToHome]</ks> If for a while no requests are received, commands are sent to the <b>trolley</b> for return to <em>HOME</em>.
                  
                <li> If a new request arrives during returnig to <em>HOME</em>, it must be immediately handled.
                  
							</ul>
						</td>
						<td>
							<ul style="font-family: Consolas; font-size: 15px">
								<li><b>client</b> send a dispatch to <b>parkingmanagerservice</b>
									<tt>pickup(TOKENID)</tt>
									to notify his interest in
									in picking his car from parking-area.
								<li>When the car is in <em>OUTDOOR-area</em>, the <b>client</b> takes his car away, then
									emits an event <tt>carwithdrawn</tt>.
							</ul>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<center>
								<bc>Parking-manager</bc>
							</center>
						</td>
					</tr>
					<tr>
						<td colspan=2>
							<ul style="font-family: Consolas; font-size: 15px">
								<li>The features related to the <tt>parking manager</tt> and its GUI are not considered
									for
									the time being.
									Consequently, neither the thermometer or the fans are considered.
								<li>Any alarm (timeout) emitted by the <b>outsonar</b> is not managed.
							</ul>
						</td>

					</tr>
				</table>
				<br>
    In this SPRINT we have added to the system a component <k>Trolley</k> with relative features. So now the movements into the enviroment are not simulated with some delays, but they are actually
    performed by a virtual robot. It's also intruduced a software component to handling and representing the virtual enviroment, in which the robot moves.
    <br>
    Subsequent to the changes made to the system, we proceed to analyze the problems encountered in this SPRINT, always considering valid the observations and analyses of the previous SPRINT about
    the already implemented components that have not been modified.
    
    <h4>Map - Configuration own map</h4>
    <p>As mentioned in requirements we need to a map that virtually represents our environment. This map it was provided by the customer
      by a software component, which documentation of its functioning is reported in 
      (<a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.planner20/userDocs/LabPlanner.html">LabPlanner.html</a>). <br>
      The client also provides us a library (<a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/unibolibs/IssActorKotlinRobotSupport-2.0.jar"><ks>IssActorKotlinRobotSupport-2.0.jar</ks></a>)
      that contains a set of tools that permits to interact and work with the system map.
      <center><img src="./img/plant.png"  width="425" height="300"></center>
    </p>
    <p>Map is necessary as a support for the planner (that is managed by some tools in the library) to calculate the fastest and safe path to a destination and to keep track of trolley moves.
      When trolley do a movement the cell of the map on which trolley is located, is updated.</p>
    <p>In our system, position of obstacles are setted a priori, because they represent boundary wall and the parking slot,
      whose position is fixed and cannot change over time. However, through one of the available tool, it is given the possibility
      to modify a specific cell of the map in case occurs.</p>
    <p>The map that is necessary to proper functioning of the system, is build througth an ad hoc handmade function that automatically creates
      the specific map file that it will be used by our system. This function can be modified in case which, in future, the parking structure change.</p>
    
    <h4>Trolley</h4>
      In this version will be added the <k>Trolley</k>. It's a software component that simulates the behavior of a real robot. This component was provided to us by the customer within the project 
      <ks><a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.qak21.basicrobot">it.unibo.qak21.basicrobot</a></ks>.<br>
    How <k>trolley</k> works is specified within the specific documentation released together with the software component <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html">basicrobot2021</a>.<br>
  To the functionalities already implemented by the Trolley it is necessary to add some others.<br><br>
  	<ul>
		<table style="border: solid 0px">
			<tr>
			<td style="border: solid 0px ; margin-right:150px">
				<li><em>Trolley status</em>: it is necessary to consider the state of the Trolley. Possible states are <k>idle</k>, <k>working</k> and <k>stopped</k>. The initial Trolley state is <k>idle</k>, it switch to <k>working</k> while making movements and his state became <k>stopped</k> only through the direct intervention of the <b>parking-manager</b> (which is not considered in this SPRINT).
			</td>
			<td style="border: solid 0px ; padding-right:100px">
				<center><img src="./img/status.png" width="230" height="400" ></center>
			</td>
		</tr>
		</table>
		<br>
      <li><em>Direction handling</em>: every time the <k>Trolley</k> completes a transport it is necessary to turn the <i>"head of the robot"</i> in the appropriate direction for loading and 					  	  unloading cars. It is possible to obtain this checking the direction in which the trolley is facing and make it turn on itself until obtaining the correct direction according to its position 				 into the map.
		<center><img src="./img/plantDir.png" width="425" height="300" ></center>
        <li id="obstacle"><em>Obstacle handling</em>: In rare and special cases there may be unexpected events that add obstacles in the environment.<br>
          In these cases, if the Trolley encounters obstacles on its path that were not already present on the map, it should stop its movement, the obstacle should be added on the map, and the 			  		  Trolley should recalculate a new path to reach its goal.
    </ul>
    
    <h4>Parking-slots traslation</h4>
    	The <k>trolley</k> can be commanded to reach a certain point on the map, indicated by a pair of coordinates.
    Relevant locations within the environment, such as <i>parking slots</i>, <i>indoor</i> and <i>outdoor</i> are identified by the system in the form of natural language words, so it's necessary to
    traslate these in the relative pair of coordinates understandable by the <b>planner</b> provided by customer, which calculates the list of movements that the <k>Trolley</k> must carry out to 
    reach the goal.
    
				

				<h3>Logical Architecture</h3>
				<p>
					<table style="width:100%" border="1">
						<tr>
							<td style="width:50%;">
								<p>Our system <tt>ParkingManagerService</tt> it's composed by seven <ks>actors</ks> in
									the same context <tt>ctxParkingservice</tt>, everyone of them
									providing a different service or simulating a certain component.</p>
								<p>Actors that we implement, will be of <ks><a
											href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/userDocs/LabQakIntro2021.html">QActor</a>
									</ks>
									type.</p>
								<ul>
									<li><b>parkingmanagerservice</b>
									<li><b>client</b>
                  					<li><b>trolleycmd</b>
									<li><b>weightsensor</b> (mock-actor)
									<li><b>outsonar</b> (mock-actor)
									<li><b>thermometer</b> (mock-actor)
									<li><b>fan</b> (mock-actor)
								</ul>

							</td>
							<td>
								<center><img src="./img/actors.png"></center>

							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>parkingmanagerservice: </ks><br><br>
								</center>
							
								This QActor represents the system. It handles, checking also if several conditions are satisfied, and elabotares all client's requests: <tt>reqenter</tt>,
								<tt>carenter</tt> and <tt>pickup</tt>.
								It provides the clients the <em>SLOTNUM</em> and the <em>TOKENID</em>. <br>
								It coordinates the movements of the <b>trolley</b>, sending to it the positions to reach. <br>
								This actor also triggers the activation of:
								<ul>
									<li><tt>weightsensor</tt>, through the event <tt>carindoorarrival</tt>.
									<li><tt>thermometer</tt> by sending a dispatch <tt>startthermometer</tt> to it.
									<li><tt>sonarhandler</tt> by sending a dispatch <tt>startsonar</tt>  to it.
								</ul>
								
							</td>
							<td>
								<center>
									<ks>client: </ks><br><br>
								</center>
								
								It's the QActor that sends the requests (<tt>reqenter</tt> and <tt>carenter</tt>) to the
								system during the parking phase
								and sends dispatch (<tt>pickup</tt>) during the picking phase.<br>
								It replaces, in this version, the role of the <ks>ParkServiceGUI</ks>, in particular,
								for the moment, it's simulated the operations related to a single client.
               	<br>
                In the next SPRINT this QActor will be removed because it will be introduced the <ks>ParkServiceGUI</ks>.

							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>weightsensor: </ks><br><br>
								</center>
								
								This mock-actor generates a random value that represents the
								weight of car in entrance and propagates it by emitting an event
								<tt>weightsensor</tt>.<br>
                This actor has the task of updating <em>INDOOR-area</em> status when he perceives the precense or absence of a car in this area.<br>
								It starts the simulation when perceives the <k>carindoorarrival</k> event, emitted by <b>parkingmanagerservice</b>, as previously mentioned.
							</td>
							<td>
								<center>
									<ks>outsonar: </ks><br><br>
								</center>
								
								This actor has a boolean variable <k>busy</k>, that indicates if
								the car is present in the outdoor, so as to simulate a real sensor. It start the
								simulation when perceives <k>caroutdoorarrival</k> event, emitted by <b>parkingmanagerservice</b>, as previously mentioned.<br>
                This actor has the task of updating <em>OUTDOOR-area</em> status when perceives the precense or absence of a car in the related area.<br>
                When the simulation stats, it's activated also an internal timer. <br>
								This timer performs a countdown from <tt>DTFREE</tt> value, if it arrives to 0 it's
								emitted an event <tt>timeout</tt>.
								The countdown is implemented with a <a
									href="https://en.wikipedia.org/wiki/Coroutine">Coroutine</a>,
								called <tt>mainScope</tt> which is cancelled
								<pre>mainScope.cancel()</pre> when the
                outsonar detects the <k>carwithdrawn</k> event, emitted by <b>client</b> indicating that the car has been taken
                out of the <em>OUTDOOR-area</em>.
							</td>
						</tr>
						<tr>
							<td>
								<center>
									<ks>thermometer: </ks><br><br>
								</center>
								
								
                This mock-actor is activated immediately, during the initialization of <b>parkingmanagerserive</b>. It performs two
								different tasks:
								<li>emit continuously an event, in which are the current temperature of environment</li>
								<li>to cyclically increment the value of temperature, this to simulate the increasing of
									environment temperature during his activity</li>
								For it coherence with requirements, we have fixed a constant value
								<k>maxTemp</k> that indicates upper temperature limits of system operation. <br> It's
								necessary to decide a value that represent the optimal temperature at which fan can be
								stopped, we indicate this with constant value <k>minTemp</k>.
								When temperature has reached the upper limit, fan actor send to thermometer a dispatch
								message <tt>stopinc</tt>, which has the function of ending temperature increase process.
								On the other hand, when the temperature has returned to the working values, this is
								reported through an event <tt>normtemp</tt> emitted by fan, the process of increasing
								temperature can restart.
							</td>
							<td>
								<center>
									<ks>fan: </ks><br><br>
								</center>
								
								This mock-actor is strictly related with thermometer actor. It evaluates every
								<tt>temp</tt> event that thermometer emit and check if the temperature of the
								environment
								is under the max prefixed temperature values. If temperature exeed the limits, fan actor
								send a dispatch message <tt>stopinc</tt> to the thermometer; this message is required to
								stop execution of increasing process.<br>
								When fan start his execution, it start to decrease temperature, until this reaches <k>
								minTemp</k>. Then an event is emitted <tt>normtemp</tt> that warns that the
								simulation of increasing temperature can restart and fan actor terminate his work.
							</td>
              
						</tr>
            <tr>
            	<td colspan="2">
								<center>
									<ks>trolleycmd: </ks><br><br>
								</center>
								
                
               This QActor works as an intermediary between the system and the remote virtual robot.<br>
               It can receive from <b>parkingmmanagerservice</b> dispatch <tt>move:move(GOAL)</tt>, where <i>GOAL</i> represents the location that must be reached by the Trolley inside the
               environment. <br>
               this actor uses some functions implemented in TrolleySupport.kt to obtain from the GOAL a set of moves that the robot must make to reach it.
               In particular, the GOAL is translated into the corresponding pair of coordinates, then they are passed as arguments to a method of a class into the package "itunibo.planner" 
               inside the library <a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/unibolibs/IssActorKotlinRobotSupport-2.0.jar"><ks>IssActorKotlinRobotSupport-2.0.jar</ks>
               </a>, provided by the client.<br>
               From the obtained set of moves, this QActor sends to the robot one command at a time, as long as there are still moves to perform.
               The commands of <k>backward</k> and <k>forward</k> are managed in asynchronous way, that is after their sending, it waits for a fixed time <tt>StepTime</tt> and after it is sent a
               command of <k>halt</k> to interrupt the move.<br>
                This QActor also handles collisions, <a href="#obstacle">as already explained</a>.
							 
							</td>
            </tr>
						<tr>
							<td colspan="2">
								<center><img src="img/logicalArchitecture.png"></center>
							</td>
						</tr>
					</table>
				</p>
				
		</div>
		<h2>Test plans</h2>
		
		<p>
			In this test plan are considered only <ks>non-distributed</ks> tests.
			<br>
			<p>
				Tests is built using CoapObserver provided by the costumer in the project <ks>it.unibo.qak21.basicrobot
				</ks> (<a
					href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_3/it.unibo.ParkManagerService_s3./test/it/unibo/parkingmanagerservice/test/utils/CoapObserverForTesting.kt">CoapObserverForTesting.kt</a>).
				<br>
        In this SPRINT we have added only the <k>Trolley</k> compared to the previous SPRINT, so for the correct functioning of the <b>parkingmanagerservice</b> the tests done in the
        previous sprint are sufficient.
        In this phase, the tests will be limited to verify the correct functioning of the <k>Trolley</k> in different situations. <br>
        In order to observe trolley movements, we will use the virtual enviroment provided by costumer. To start this eviroments, it's necessary launch a <i>.yaml</i> file with <b>Docker</b>,
        in particular running: <pre> docker-compose -f basicrobotVirtual.yaml up </pre>
			</p>
			<kc>TestPlans goals:</kc>
			<ul>
				<li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b></k>. <br> <br>
					
         <div class=remark2>
            <h3>Workflow</h3>
           During this test, it's verified the correct behaviour of the system. This kind of test was performed in the previous SPRINT, but in this case, the aim test is to check if <k>Trolley</k>
           movements are correct. Only the movements of the <k>trolley</k> are verified because the correct functioning of the rest of the system has already been checked previously.
         </div>
				<li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
				<br>
          </ul>
				Here it's tested the correct behaviour of <tt>trolley</tt>. During this kind of test, like in the <k>integration test</k>, the components updates some resouces whose values
				are observed and then checked.

		<div class=remark2>
			<h3>Simple moves test</h3>
      This is a preliminary test to check if the libraries used for the <k>trolley</k> movements and for the map updating, work correctly. In this way we can use the map to conduct future tests.
		</div>
		<div class=remark2>
            <h3>Path test</h3>
				The aim of this test is to verify if the <k>Trolley</k>, after having received the command to go to a certain position into the parking, 
				obtains and executes the right path to reach it. After the movements, it is checked that the calculated path is the one actually executed by the <k>Trolley</k>.
        </div>
          <div class=remark2>
          	<h3>Direction test</h3>
            This test has the goal of verifying that at the end of current travel, the <k>trolley</k> assumes the correct direction. 
            Depending on the position in which the robot is located at the end of the travel, the final direction will be different.
            For example if the destination of the travel is "indoor" that is located in the upper-right corner of the map, 
            final position of the trolley will be <tt>downDir</tt>. For park slot "p1" will be instead <tt>leftDir</tt>, so it will be for all parking slots on the left.
            For the parking slot on the right the final direction will be <tt>rightDir</tt>.
          </div>
          <div class=remark2>
            <h3>Trolley status behaviour test</h3>
            The goal of this test is to verify that in different situation the <k>trolley</k> change his status. In this version trolley status can be "IDLE" and "WORKING".
            <ul>
            <li>Trolley assumes <ks>IDLE</ks> status when it is waiting for a request of work or, after the end of a work,
              it doesn't have nothing to do and no job request is sent.
            <li>Trolley must assume <ks>WORKING</ks> state when it is actually doing a job. Returning to "home" position is not considered as a "WORKING" state.
            </ul>
          </div>
            

			</ul>
		</p>
		
		<h2>Project</h2>

		<div class=remark>
			<p><h3>Parking Phase - <a href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_3/it.unibo.ParkManagerService_s3/src/parkingservice.qak">parkingservice.qak: </a></h3></p>
			<table>
				<tr>
					<td>
<pre>
State acceptReqEnter{
} Goto ready if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree &&
		unibo.robot.TrolleyKb.trolleyStatus != `it.unibo`.utils.TrolleyStatus.STOPPED#]
	else readyOnlyReqEnter
			

State checkOutdoor{
}Goto readyOnlyOutdoor if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree &&
			unibo.robot.TrolleyKb.trolleyStatus != `it.unibo`.utils.TrolleyStatus.IDLE #]
	else notReady
</pre>
					</td>
					<td style='text-align:center; padding: 10px;'>
						<p>
							Respect to Sprint 2 check operations, in this Sprint we also check <b>Trolley</b> Status.    
						</p>
					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
State moveToHome{
	[# if(unibo.robot.TrolleyKb.trolleyStatus == `it.unibo`.utils.TrolleyStatus.IDLE  && GOAL != "home") { #]
		println("##### IN MOVE TO HOME ##########")
	println("Moving Trolley to HOME")
	updateResource[# "toHome(V)" #]
	[# GOAL = "home" #]
	forward trolley -m move : move($GOAL) 
	[# } #]
} Goto check	
</pre>
					</td>
					<td style="padding: 10px;">
						If <b>Trolley</b> doesn't receive any requests for a certain time and he is in <em>IDLE</em> Status, it automatically come back to home.
					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
State acceptin{
	//================[ acceptIN ]=====================	
	[# SLOTNUM = `it.unibo`.utils.ParkingSlotsKb.findSlot() #]
	[# `it.unibo`.utils.ParkingSlotsKb.setSlot(SLOTNUM, false) #]

	[# if(! `it.unibo`.utils.ParkingSlotsKb.indoorFree || 
			unibo.robot.TrolleyKb.trolleyStatus == `it.unibo`.utils.TrolleyStatus.STOPPED
	){ #]
		replyTo reqenter with waitIndoor : slotsnum ($SLOTNUM)
		updateResource [# "wait(${SLOTNUM}) " #]
	[# } #]
	[# else {#]
	//================[ informIN ]=====================
	replyTo reqenter with slotsnum : slotsnum ($SLOTNUM)
	updateResource [# "slotnum(${SLOTNUM}) " #]
	println("SLOTNUM = $SLOTNUM | SERVICE" )
	[# } #]	
} Transition t0
	whenRequest carenter -> carenter
							
State carenter{
	emit carindoorarrival : cia(car_arrived)  //questo lo deve catturare il weightsensor
	//================[ moveToIn ]=====================
		[# GOAL = "indoor" #]
		forward trolley -m move : move($GOAL) 
		println("Trolley is moving to Indoor | SERVICE")
	}Transition t0
		whenEvent weightsensor -> weightcheck
</pre>
					</td>
					<td style="padding: 10px;">
						In <k>acceptin</k> state, before serving an acceptin request, is also checked that <em>TrolleyStatus</em> isn't settes to <em>STOPPED</em>. <br><br>
						If the acceptin can be served and a carenter request is received, in carenter state we send to <b>Trolley</b> a message. <br>
						This message specify that it has to go to <em>INDOOR</em> in where there is a car waiting to be parcked. 
					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
State weightcheck{
	onMsg(weightsensor : weight(W)){
		[# 
			WEIGHT = payloadArg(0).toInt()
			println("Weight: " + WEIGHT)
		#]
		}
} Goto waitTrolleyIndoor if [# WEIGHT > 0 #] else weightError

State waitTrolleyIndoor{
} Transition t0
		whenEvent finished -> receipt
			
State receipt{ 
	onMsg(finished : finished(GOAL)){
		[# trolleyPos = payloadArg(0) #]
	}
	[# if(trolleyPos == "indoor") { #]
		println("Trolley is in INDOOR| SERVICE")
		[# 	INDOORTOKEN = `it.unibo`.utils.ParkingSlotsKb.generateToken(SLOTNUM) #]
		//==========[receipt]==========
		replyTo carenter with receipt : receipt($INDOORTOKEN)
		updateResource [# "receipt($INDOORTOKEN)" #]
	[# } #]
} Goto moveToSlotIn if [# trolleyPos == "indoor"#]
		else waitTrolleyIndoor
				
State moveToSlotIn{
	//========================[ moveToSlotIN ]========================
	[# 	GOAL = "p" + SLOTNUM.toString()	#] 
	forward trolley -m move : move($GOAL)
	println("Trolley moves from INDOOR to $SLOTNUM")
} Transition t0 
		whenEvent finished -> checkPark


State checkPark{
	onMsg(finished : finished(GOAL)){
		[# trolleyPos = payloadArg(0) #]
	}
} Goto parkedCar if [# trolleyPos == GOAL #]
	else parkingError
	
	
State parkedCar{
	println("Car is parked at p$SLOTNUM")
} Transition t0
		whenTime 500 -> check

</pre>
					</td>
					<td style="padding: 10px;">
						After the check of the <k>weightcheck</k> we go in a state called <k>waitTrolleyIndoor</k>. In this state we wait for a finished event (emitted by the <b>Trolley</b>).
						Subsequently in the <k>receipt</k> state we do a check on the trolley position, that if it is not equal to <em>INDOOR</em> we return back to <k>waitTrolleyIndoor</k> status.
						This means that a client could arrive in the <em>INDOOR</em> while the Trolley is performing another operation. Therefore a finished event could be emitted, but related to another operation.<br><br>
						When <b>Trolley</b> arrive to <em>INDOOR</em> and the client receive his <em>INDOORTOKEN</em> we go to MoveToSlotIn, in where is sended to trolley the position of the parking space assigned to the client. <br><br>
						At the end it's checked that the car was parked in the correct slot and return to the check state. 

					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p><h3>Picking Phase - <a href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_3/it.unibo.ParkManagerService_s3/src/parkingservice.qak">parkingservice.qak: </a></h3></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
State picking{	 	
	//====================[moveToSlotOut]========================
	delay 1000
	[# `it.unibo`.utils.ParkingSlotsKb.setSlot(CARSLOTNUM, true) 
		GOAL = "p" + CARSLOTNUM.toString()
	#]
	forward trolley -m move : move($GOAL)
	println("Trolley picking car from slot $CARSLOTNUM | SERVICE")
}
Transition t0
	whenEvent finished -> checkCarPicked

State checkCarPicked{
	onMsg(finished : finished(W)){
		[# 
			trolleyPos = payloadArg(0)
		#]
		}
} Goto moveToOut if[# trolleyPos == GOAL #]
	else trolleyToPickingSlot
	
	
State trolleyToPickingSlot{
	println("WAIT THAT TROLLEY ARRIVE AT PICKING SLOT | SERVICE")
}Transition t0
	whenTime 5000 -> check
	whenEvent finished -> checkCarPicked
		
		
State moveToOut{
	//====================[moveToOut]========================
	[# GOAL = "outdoor" #]
	forward trolley -m move : move($GOAL)
}Transition t0 	
	whenEvent  finished	-> carInOutdoor


State carInOutdoor{
	onMsg(finished : finished(W)){
		[# trolleyPos = payloadArg(0) #]
		}
	[# if (trolleyPos == "outdoor") {#]	
	emit caroutdoorarrival : coa(car_arrived)  //questo lo deve catturare il outsonar
	println("Car is in Outdoor area | SERVICE")
	[# } #]
} Goto check if [# trolleyPos == "outdoor" #]
	else outdoorError

</pre>
					</td>
					<td style="padding: 10px;">
						After getting <em>INDOORTOKEN</em>, in state picking, it's sended to the <b>Trolley</b> the position of the car that has to be transported to <em>OUTDOOR</em>.<br>
						For the same reason of the case of <tt>waitTrolleyIndoor</tt>, in <k>trolleyToPickingSlot</k>, it's checked that when a finished event is emitted, the postion of <b>Trolley</b> is equal to parking slot position. 
						Otherwise we wait for the next finished event with the correct <b>Trolley</b> position.<br><br>
						Once the machine has been picked up, Trolley brings the car to <em>OUTDOOR</em>. 
						At the end one last check is performed to determine that car was really to <em>OUTDOOR</em> and return to check state. 
						

					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p><h3>TrolleyCmd - <a href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_3/it.unibo.ParkManagerService_s3/src/parkingservice.qak">parkingservice.qak: </a></h3></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
State work{ 
	[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.IDLE #]
	[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
	updateResource [# "status($STATUS)" #]
	println("basicrobot waiting ... | TROLLEY")  
}Transition t0
	whenMsg move -> path	  


State path{
	onMsg(move : move(GOAL)){
		[# GOAL = payloadArg(0) #]
		println("GOAL = $GOAL | TROLLEY")
		run planner.getPathPlan(GOAL)
		[# CurPath = itunibo.planner.plannerUtil.getActions().toString() #]
		updateResource [# "path($CurPath)" #]
	}
	[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
	[#STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString()#]
	updateResource [# "status($STATUS)" #]
	
} Goto execPlannedMoves if [# GOAL != "home" #]
	else checkInterrupt
	
	
State checkInterrupt{
}Transition t0 
		whenTime 100   -> execPlannedMoves
		whenMsg move   -> path


State execPlannedMoves{   
	//delay 300
	[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
	println("+++++++++++++++++++++++++++++++ $CurrentPlannedMove | TROLLEY")
}
Goto doMove if [# CurrentPlannedMove.length>0 #] else halt //parkthecar


State doMove{ 	
	[#StepTime = #] run unibo.robot.robotSupport.move( "$CurrentPlannedMove" ) 
	//[# StepTime = StepTime+100 #]
}Transition t0 
		whenTimeVar StepTime   -> checkObstacle   


State checkObstacle{
}Transition t0
	whenTime 100 -> stepDone
	whenEvent obstacle -> handleObstacle


State stepDone{  
	printCurrentMessage
	[#if (CurrentPlannedMove == "w" || CurrentPlannedMove == "s") {#]
		run unibo.robot.robotSupport.move( "h" )
	[#}#]
	
	//updateResource [# itunibo.planner.plannerUtil.getMap() #]
	updateResource [# "stepdone($CurrentPlannedMove)" #]
	run itunibo.planner.plannerUtil.updateMap(  "$CurrentPlannedMove" )
	
	//run itunibo.planner.plannerUtil.showCurrentRobotState( )
	//updateResource [# "stepDone" # ]
} 
Goto execPlannedMoves if[# GOAL != "home" #]
	else checkInterrupt

	
State halt{
	[# var timeDelay = #] run planner.exactDir(GOAL)
	[# delay(timeDelay) #] 
	println("path finished | TROLLEY")
	run itunibo.planner.plannerUtil.showCurrentRobotState()
	updateResource [# "finished($GOAL)" #]
	emit finished : finished($GOAL) 
	println("finished($GOAL) | TROLLEY")
} Goto work


State handleObstacle{   
	run unibo.robot.robotSupport.move( "h" )
	println("basicrobot | handleObstacleeeeeeeeeeeeeeeeeeee CurrentMove=$CurrentMove")	
	printCurrentMessage
} Goto stepDone if[# !planner.checkObstacle(itunibo.planner.plannerUtil.getPosX(),
		 itunibo.planner.plannerUtil.getPosY()) #]
	else restart


State restart{
	run planner.getPathPlan(GOAL)
	[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
	[#STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString()#]
	updateResource [# "status($STATUS)" #]
} Goto execPlannedMoves if [# GOAL != "home" #]
	else checkInterrupt
</pre>
					</td>
					<td style="padding: 10px;">
						
						<b>trolleycmd</b> is made starting from <a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.qak21.basicrobot">basicrobot</a> regarding communication with real trolley, 
						to send it information of what move it has to perform. Instead, regarding interactions with map ad its updates we use 
						<a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.kotlinSupports">kotlinSupports</a> a library provided us by the custormer.<br><br>
						<b>trolleycmd</b> waits in <tt>work</tt> state until a <tt>move</tt> request is received. In a <tt>move</tt> request is specificated what is the destination that has to be reached.
						After receiving it, a <k>planner</k> calculate in relation to received destination, the shortest and optimal path to reach them. A path is a list of basic moves 
						(<k>w</k>, <k>s</k>, <k>l</k>, <k>r</k>). <b>trolleycmd</b> continue to exec until the planned moves of the path isn't terminated.
						For each move a message is sent to real trolley in order to actually execute that move. After a delay, represents the time <b>Trolley</b> takes to complete the move,
						the map is updated. Once Trolley reach its destination, a <tt>finished : finished($GOAL)</tt> event is emitted and it will be perceived by the <b>parkingmanagerservice</b>. <br><br>

						This is the normal process when <b>trolley</b> has to permorm a travel to one destination. However, if the destination is <k>"home"</k> the process is a little bit different.
						At the end of each move of the planned path, process go through the <em>checkInterrupt</em> status. Since during the return <k>home</k> the trolley is in the <em>IDLE</em> state, it's checked that
						a <tt>move</tt> request is received. In that case the returning to home is stopped and a new path to current destination will be calculated.<br><br>

						There are also three state that alow <b>trolley</b> to check accidental presence of obstacle. An obstacle is reported only if it is unexpected,
						if it isn't the process continues normally. If an unexpected obstacle is encountered, actual work of <b>trolley</b> is stopped, the map is updated and a new path that
						excludes that occupied cell will be calculated. After these operations the work can restart.<br><br>


					</td>
				</tr>
				<tr >
					<td colspan=2 style="border-left-color: transparent; border-right-color: transparent;">
						<p><h3>TrolleySupport - <a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_3/it.unibo.ParkManagerService_s3/resources/it/unibo/utils/TrolleySupport.kt">TrolleySupport.kt</a></h3></p>
					</td>
				</tr>
				<tr>
					<td>
<pre>
fun getPathPlan(goal : String) : Unit{
	
	when(goal){
		"home" -> {
			return plannerUtil.planForGoal("0", "0")
		}
		"outdoor" -> {
			return plannerUtil.planForGoal("6", "4")
		}
	}
}

//----------------------------------------------------------------------------

fun exactDir(goal : String) : Long {
	var time : Long  = 0 
	when(goal){
		"home" -> {
			while(plannerUtil.getDirection()!="downDir"){
				unibo.robot.robotSupport.move( "r" )
				plannerUtil.updateMap(  "r" )
				time = time + 100
			}
			return time
		}
		"outdoor" -> {
			while(plannerUtil.getDirection()!="upDir"){
				unibo.robot.robotSupport.move( "r" )
				plannerUtil.updateMap(  "r" )
				time = time + 100
			}
			return time
		}
	}
}

//----------------------------------------------------------------------------

fun checkObstacle(x : Int, y : Int) : Boolean{
		
	var pos = getObstaclePos(x, y)
	
	if(!map.isObstacle(pos.first, pos.second)){
		map.put(pos.first, pos.second, Box(true, false, false))
		return true	
	}else{
		return false
	}	
	
}

fun getObstaclePos(x : Int, y : Int) : Pair<Int, Int>{
	when(plannerUtil.getDirection()){
		
		"upDir"		-> 	return Pair(x, y-1)
	
		"downDir"	-> return Pair(x, y+1)
		
		"leftDir"	-> return Pair(x-1, y)
		
		"rightDir"	-> return Pair(x+1, y)
			
	}
	return Pair(-1, -1)
}

//----------------------------------------------------------------------------

fun mapConfiguring() : Boolean{
		
	var parkMap = "parkingMap"
	
	var i : Int
	var j : Int
	for (i in 0..6){
		for (j in 0..4){
			 if(i==0 && j==0){println("RRRRRRRRRRRRRRRRRRR")}
			 else
				 map.put(i, j, Box(false, true, false))
		}
	}	
	for(i in 0..7){
		map.put(i, 5, Box(true, false, false))
	}
	
	for(i in 0..4){
		map.put(7, i, Box(true, false, false))
	}
	
	
	map.put(2, 1, Box(true, false, false))
	
	map.put(3, 1, Box(true, false, false))
	
	map.put(2, 2, Box(true, false, false))
	
	map.put(3, 2, Box(true, false, false))
	
	map.put(2, 3, Box(true, false, false))
	
	map.put(3, 3, Box(true, false, false))
		
	plannerUtil.showMap()
	plannerUtil.saveRoomMap(parkMap)
	
	return true
		
}

</pre>
					</td>
					<td style="padding: 10px;">
						
						<b>TrolleySupport</b> is a kotlin file that contain some functions that help us to obtain informations usefull to the <b>trolleycmd</b>.
						<ul>
							<li><ks>getPathPlan(goal : String)</ks>: accept as parameter one of known destinations of our environment that <b>trolley</b> has to reach and it return the list of
								 planned moves that has to be performed to reach it. 
							<li><ks>exactDir(goal : String)</ks>: according to the cell, representing one of known destinations of our environment, we are in,
								 this function permits to make the trolley assume the correct direction.
							<li><ks>checkObstacle(x : Int, y : Int)</ks> and <ks>getObstaclePos(x : Int, y : Int)</ks>: permit us to check if an obstacle is unxepected or not. If it is unxepected, it updates the map.
							<li><ks>mapConfiguring()</ks>: is the function that allowed us to create our custom environment map accordind to requirements.
						</ul> 

					</td>
				</tr>
			</table>
		</div>

		<h2>Testing</h2>
		<a href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_3/it.unibo.ParkManagerService_s3/test/it/unibo/parkingmanagerservicetest/TestPlan.kt">TestPlan.kt </a><br>
		<p>
			In this test plan are considered only <ks>non-distributed</ks> tests.
			<br>
			<p>
				Tests is built using CoapObserver provided by the costumer in the project <ks>it.unibo.qak21.basicrobot
				</ks> (<a
					href="https://github.com/P-damicis/Automated_Car_Parking/blob/main/sprint_3/it.unibo.ParkManagerService_s3/test/it/unibo/parkingmanagerservice/test/utils/CoapObserverForTesting.kt">CoapObserverForTesting.kt</a>).
				<br>
        In this SPRINT we have added only the <k>Trolley</k> compared to the previous SPRINT, so for the correct functioning of the <b>parkingmanagerservice</b> the tests done in the
        previous sprint are sufficient.
        In this phase, the tests will be limited to verify the correct functioning of the <k>Trolley</k> in different situations. <br>
        In order to observe trolley movements, we will use the virtual enviroment provided by costumer. To start this eviroments, it's necessary launch a <i>.yaml</i> file with <b>Docker</b>,
        in particular running: <pre> docker-compose -f basicrobotVirtual.yaml up </pre>
			</p>
			<kc>TestPlans goals:</kc>
			<ul>
				<li>Ensure that the workflow of the system meets a set of requirements <k><b>(integration testing)</b></k>. <br> <br>
					
         <div class=remark2>
            <h3>Workflow</h3>
           During this test, it's verified the correct behaviour of the system. This kind of test was performed in the previous SPRINT, but in this case, the aim test is to check if <k>Trolley</k>
           movements are correct. Only the movements of the <k>trolley</k> are verified because the correct functioning of the rest of the system has already been checked previously.
		   <br><br>
		   <table>
			   <tr>
				   <td>
<pre>
clientactor!!.request("reqenter","reqenter(bob)","parkingmanagerservice")
		
delay(2000)

//--------------------------------------------------------------------------------

clientactor!!.request("carenter","carenter(ok)","parkingmanagerservice")

var result = channelForObserver.receive()
println("+++++++++ trolleyInIndoor RESULT=$result +++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("indoor", position)

var result2 = channelForObserver2.receive()
var token = result2.substringAfter("(",result2).substringBefore(")",result2).toInt()
println("token = $token")

delay(4000)
</pre>
				   </td>
				   <td style="padding: 10px;">
						<p>
							In this part of workflow testing is checket <b>Trolley</b> position that after a <tt>carenter</tt> request by <b>Client</b> has to be <em>INDOOR</em>. 
							Is also checke that the <tt>TOKENID</tt> is corrrectly given to <b>Client</b>.
						</p>
				   </td>
			   </tr>
			   <tr>
				<td>
<pre>
result = channelForObserver.receive()
println("+++++++++ trolleyToParkingSlot RESULT=$result +++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("p1", position)

delay(3000)
</pre>
				</td>
				<td style="padding: 10px;">
					 <p>
						 After is checked that <b>Trolley</b> bring the car to his assigned parking slot. Is so checked that the final <b>Trolley</b> position is equal to that slot.
					 </p>
				</td>
			</tr>
			<tr>
				<td>
<pre>
clientactor!!.forward("pickup","pickup($token)","parkingmanagerservice")
		
result = channelForObserver.receive()
println("+++++++++ trolleyToParkingSlot(PICKUP) RESULT=$result +++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("p1", position)

delay(4000)

//-----------------------------------------------------------------------------------

result = channelForObserver.receive()
println("+++++++++ trolleyInOutdoor RESULT=$result +++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("outdoor", position)

delay(6000)
</pre>
				</td>
				<td style="padding: 10px;">
					 <p>
						Time is left for the trolley to return home. So <b>Client</b> makes a pickup request give his personal <em>TOKENID</em>.
						In this test is cheked that <b>Trolley</b> effectively goes to correct parking slot in which the car is. 
						Is so checked that the final <b>Trolley</b> position is equal to that slot.
					 </p>
					 <p>
						After that, the <b>Trolley</b> takes the car that needs to be brought to the exit and goes to <em>OUTDOOR</em>.
						It is thus checked that the final position of the <b>Trolley</b> is equal to <em>OUTDOOR</em>.
					 </p>
				</td>
			</tr>
			<tr>
				<td>
<pre>
result = channelForObserver.receive()
println("+++++++++ trolleyInHome RESULT=$result +++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("home", position)
</pre>
				</td>
				<td style="padding: 10px;">
					 <p>
						 After some time, the <b>Trolley</b> return to its <em>HOME</em>. At the finish of this operation is checked that <b>Trolley</b> position is equal to <em>Home</em>.
					 </p>
				</td>
			</tr>
		   </table>
         </div>
				<li>Ensure that some components work properly individually. <k><b>(unit testing)</b></k> <br>
				<br>
          </ul>
				Here it's tested the correct behaviour of <tt>trolley</tt>. During this kind of test, like in the <k>integration test</k>, the components updates some resouces whose values
				are observed and then checked.

		<div class=remark2>
			<h3>Simple moves test</h3>
			This is a preliminary test to check if the libraries used for the <k>trolley</k> movements and for the map updating, work correctly. In this way we can use the map to conduct future tests.
			<br><br>
			<table>
				<tr>
					<td>
<pre>
val move = "w"
		
delay(3000)

delay(robotSupport.move(move))
robotSupport.move("h")

delay(1000)

plannerUtil.updateMap(  "$move" )

println("+++++++++ testSingleMove ")	

var curPos = plannerUtil.get_curPos().toString()

testingObserver!!.addObserver(channelTmp,"null")
trolleyObserver!!.addObserver(channelTmp,"null")

assertEquals(curPos,"(0, 1)")
</pre>
					</td>
					<td style="padding: 10px;">
						<p>
							In this test the trolley is made to make one move only. After the move has been completed is ckeched that postion of the <b>Trolley</b> is the expected one. 
						</p>
					</td>
				</tr>
			</table>
		</div>
		<div class=remark2>
            <h3>Path test</h3>
				The aim of this test is to verify if the <k>Trolley</k>, after having received the command to go to a certain position into the parking, 
				obtains and executes the right path to reach it. After the movements, it is checked that the calculated path is the one actually executed by the <k>Trolley</k>.
				<br><br>
				<table>
					<tr>
						<td>
<pre>
myactor!!.forward("move","move(p5)","trolley")
trolleyObserver!!.addObserver(channelForObserver, "path")
trolleyObserver!!.addObserver(channelForObserver2, "stepdone")

println("+++++++++ testTraveToDestination ")	

var result = channelForObserver.receive()
var expectedpath : String = result.substringAfter("(",result).substringBefore(")",result).toString()
expectedpath = expectedpath.replace("[","").replace("]","").replace(",","").replace(" ","")
println("EXP__PATH: $expectedpath")
//--------------------------------------------------------------------------------

var realpath = ""
var len = expectedpath.length
println("LENGTH....$len")
for(i in 1..expectedpath.length) {	
result = channelForObserver2.receive()
result = result.substringAfter("(",result).substringBefore(")",result)
realpath = realpath.plus( result )
}

println("REAL__PATH: $realpath")
	testingObserver!!.addObserver(channelTmp,"null")
assertEquals(expectedpath, realpath)
</pre>
						</td>
						<td style="padding: 10px;">
							 <p>
								In this test after calculate the path that has to performed by <b>Trolley</b> to reach the given destination,
								is checked that at the end the effectively executed path is equal to the calculated one.
							 </p>
						</td>
					</tr>
				</table>
        </div>
          <div class=remark2>
          	<h3>Direction test</h3>
            This test has the goal of verifying that at the end of current travel, the <k>trolley</k> assumes the correct direction. 
            Depending on the position in which the robot is located at the end of the travel, the final direction will be different.
            For example if the destination of the travel is "indoor" that is located in the upper-right corner of the map, 
            final position of the trolley will be <tt>downDir</tt>. For park slot "p1" will be instead <tt>leftDir</tt>, so it will be for all parking slots on the left.
            For the parking slot on the right the final direction will be <tt>rightDir</tt>.
			<br><br>
			<table>
				<tr>
					<td>
<pre>
myactor!!.forward("move","move(indoor)","trolley")
			
var result = channelForObserver.receive()
var direction = plannerUtil.getDirection()
println("+++++++++ trolleyInIndoor RESULT=$result - DIRECTION=$direction+++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("indoor", position)
assertEquals("downDir", plannerUtil.getDirection())

delay(4000)
//----------------------------------------------------------------------------------

myactor!!.forward("move","move(p1)","trolley")

result = channelForObserver.receive()
direction = plannerUtil.getDirection()
println("+++++++++ trolleyInP1 RESULT=$result - DIRECTION=$direction+++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("p1", position)
assertEquals("leftDir", plannerUtil.getDirection())

delay(4000)
//----------------------------------------------------------------------------------

myactor!!.forward("move","move(outdoor)","trolley")

result = channelForObserver.receive()
direction = plannerUtil.getDirection()
println("+++++++++ trolleyInOutdoor RESULT=$result - DIRECTION=$direction+++++++++")
position = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("outdoor", position)
assertEquals("upDir", plannerUtil.getDirection())
</pre>
					</td>
					<td style="padding: 10px;">
						<p>
							In this test, for every destination reached by <b>Trolley</b> is checked that his final direction is equal to the expected one.
						</p>
					</td>
				</tr>
			</table>
          </div>
          <div class=remark2>
            <h3>Trolley status behaviour test</h3>
            The goal of this test is to verify that in different situation the <k>trolley</k> change his status. In this version trolley status can be "IDLE" and "WORKING".
            <ul>
            <li>Trolley assumes <ks>IDLE</ks> status when it is waiting for a request of work or, after the end of a work,
              it doesn't have nothing to do and no job request is sent.
            <li>Trolley must assume <ks>WORKING</ks> state when it is actually doing a job. Returning to "home" position is not considered as a "WORKING" state.
            </ul>
			<br>
			<table>
				<tr>
					<td>
<pre>
var result = channelForObserver.receive()
println("+++++++++ trolleyInitialState RESULT=$result+++++++++")
status = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("IDLE", status)

delay(4000)
//----------------------------------------------------------------------------------
myactor!!.forward("move","move(indoor)","trolley")


result = channelForObserver.receive()
println("+++++++++ trolleyWorkingState RESULT=$result+++++++++")
status = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("WORKING", status)

delay(4000)
//----------------------------------------------------------------------------------

result = channelForObserver.receive()
println("+++++++++ trolleyEndWorkState RESULT=$result+++++++++")
status = result.substringAfter("(",result).substringBefore(")",result)
assertEquals("IDLE", status)
</pre>
					</td>
					<td style="padding: 10px;">
						<p>
							In this test is checked <b>Trolley</b> status in different situations.
							<ul>
								<li>At the system start is checked that <b>Trolley</b> status is <em>IDLE</em>.
								<li>After a request of work that <b>Trolley</b> status is <em>WORKING</em>.
								<li>At the end of the work that <b>Trolley</b> status is <em>IDLE</em>.
							</ul>
						</p>
					</td>
				</tr>
			</table>
          </div>
            

			</ul>
		</p>
		<h2>Deployment</h2>
		The deployment of SPRINT 3 consists in a release on a <a
			href="https://github.com/P-damicis/Automated_Car_Parking/tree/main/sprint_3">Github repository</a>.

		<h2>Maintenance</h2>
		This is the third SPRINT, it is expected that the next one will be the final SPRINT, because to get the complete application is missing only the implementation of GUIs.
		<br /><br />
	</div>

	<div style="background-color:rgba(42, 7, 241, 1.0); width:100%;text-align:center;color:white">
		<table style="width:100%" border="1">
			<tr>
				By Mantovani Leonardo and Pier Domenico d'Amicis

			</tr>
		</table>
	</div>
</body>

</html>
