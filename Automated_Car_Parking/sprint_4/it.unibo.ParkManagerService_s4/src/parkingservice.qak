System parkingservice  
    
/*
 * 8090: trolley env
 * 5693: parkingmanagerservice
 * 8081: clientGUI
 * 8083: managerGUI
 * 8028: sonaronrasp
 */    
    
//DECOMMENTARE se si usa il sonar fisico    
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "parkingArea/feedback"    
    
Request reqenter 		: reqenter(V)
Reply slotsnum 			: slotsnum(SLOTNUM)
Reply waitIndoor 		: slotsnum(V)
Reply reqenterTimeout 	: slotsnum ($SLOTNUM) 
 
Dispatch move  : move(GOAL)
Event finished : finished(V)
Event obstacle : obstacle( T )
Dispatch stopTrolley   : stop(V)
Dispatch resumeTrolley : resume(V)
 
Request carenter : carenter(V)
Reply receipt  : receipt(INDOORTOKEN)

Dispatch pickup : pickup(OUTDOORTOKEN)

//------------------------------------------------------------------------------------------------
Dispatch startManager : start(V)
Dispatch systemready : ready(V)
Dispatch asd : asd(V)
//-------------------------------------------------------------------------------------------------
Dispatch startthermometer : thermometer(V)
Dispatch startsonar : sonar(V)
Dispatch starttimer : timer(V) 
Dispatch stoptimer : timer(V) 

Dispatch updateGui : value(V)

Dispatch move : move(GOAL)
//------------------------------------------------------------------------------------------------

Event carindoorarrival  : cia(V)
Event caroutdoorarrival : coa(V)
Event weightsensor		: weight(W)
Event sonaroutdoor    : distance( V )
Event alarm 			: timeout(alarm)
   
//------------------------------------------------------------------------------------------------
Event finished 			: finished(V) 
Event obstacle : obstacle( T )

Dispatch stopTrolley : stop(V)
Dispatch resumeTrolley : resume(V)
//------------------------------------------------------------------------------------------------


Context ctxParkingservice  ip [host="localhost" port=5683]

CodedQActor outsonar 		context ctxParkingservice className "sonarSimulator"
CodedQActor outdoortimer 	context ctxParkingservice className "outdoorTimer"
CodedQActor weightsensor 	context ctxParkingservice className "weightsensorSimulator"
CodedQActor guiupdater 		context ctxParkingservice className "guiUpdater"

//------------------------------------------------------------------------------------------------
CodedQActor thermometer context ctxParkingservice className "thermometerSimulator"
CodedQActor fan context ctxParkingservice className "fanSimulator"
//------------------------------------------------------------------------------------------------

/* 
 * ------------------------------------------------------------------
 * Assumptions :
 * • Final SPRINT
 * ------------------------------------------------------------------
*/  
/* 
QActor client context ctxParkingservice{
	State s0 initial{
		
	}Transition t0
		whenTime 10000 -> work
	
	State work{
		request parkingmanagerservice -m reqenter:reqenter(Jim)
		delay 5000
		request parkingmanagerservice -m carenter:carenter(Jim)

	}
}
*/
QActor parkingmanagerservice context ctxParkingservice{
	[#
	lateinit var weightSensorActor 	: ActorBasic
	lateinit var outSonarActor 		: ActorBasic
	lateinit var outdoortimerActor 	: ActorBasic
	lateinit var thermometerActor 	: ActorBasic
 	lateinit var fanActor 			: ActorBasic
 	lateinit var guiUpdaterActor	: ActorBasic
	
	var SLOTNUM = 1
	var FREESLOTS = 6
	var INDOORTOKEN  = "1" //tokenid dato al client
	var WEIGHT 		  = 0
	
	var OUTDOORTOKEN = "1" //tokenid ricevuto dal client
	var CARSLOTNUM =  0
	
	var GOAL 	   = ""
	var trolleyPos = ""
	
	var simulatedsonar = true //false
	
	#]
	 
	State s0 initial{
		[#
		if(simulatedsonar){
			outSonarActor   = sysUtil.getActor("outsonar")!!
		} else 
			outdoortimerActor 	= sysUtil.getActor("outdoortimer")!!
		weightSensorActor 		= sysUtil.getActor("weightsensor")!!
		thermometerActor 		= sysUtil.getActor("thermometer")!!
		fanActor				= sysUtil.getActor("fan")!!
		guiUpdaterActor			= sysUtil.getActor("guiupdater")!!
		#]	
	}Transition t0
			//whenTime 5000 -> setup
			whenMsg startManager -> setup
	
	
	State setup{
		delay 2000
		forward thermometer -m startthermometer : thermometer(on)
		forward sonarhandler -m startsonar : sonar(on)
				
		updateResource[# "systemready(start)" #]		 
		updateResource [# "freeslots(${FREESLOTS})" #]
	
		forward guiupdater -m updateGui : indoorStatus(FREE)
		forward guiupdater -m updateGui : outdoorStatus(FREE)
		forward guiupdater -m updateGui : slotLiberi($FREESLOTS)
		forward guiupdater -m updateGui : fan(OFF)
		[# val W = "0 KG" #]
		forward guiupdater -m updateGui : weight($W)
		
/* 
		updateResource [# "{\"slotLiberi\":\"$freeSlots\"}"  #]
		updateResource [# "{\"indoorStatus\":\"FREE\"}" #]
		updateResource [# "{\"outdoorStatus\":\"FREE\"}"  #]
*/
		forward trolley -m systemready : ready(system)
		println("Park System START | SERVICE")
	}Goto check
	
	
	State check{
		delay 2000
	}																		//Se non c'è posto non deve essere cliccabile la req enter
	Goto acceptReqEnter if [# `it.unibo`.utils.ParkingSlotsKb.checkSlots() > 0 #] // eliminare il controllo e rispondere con slotnum(0) ???
		else checkOutdoor
		
		
	State acceptReqEnter{
	} Goto ready if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree &&
						unibo.robot.TrolleyKb.trolleyStatus != `it.unibo`.utils.TrolleyStatus.STOPPED
					#]
	 	else readyOnlyReqEnter
				
	
	State checkOutdoor{ //IL tasto della pikcup deve sempre essere cliccabile
	}Goto readyOnlyOutdoor if [# `it.unibo`.utils.ParkingSlotsKb.outdoorFree &&
								unibo.robot.TrolleyKb.trolleyStatus != `it.unibo`.utils.TrolleyStatus.STOPPED #]
		else notReady
						
								
	State ready{
		println("INDOOR and OUTDOOR Avaiable | SERVICE")
	}Transition t0 
					whenTime 	5000     -> moveToHome
					whenRequest reqenter -> acceptin
					whenMsg		pickup	 -> acceptout
				
				
	State readyOnlyReqEnter{
		println("INDOOR Avaiable | SERVICE")
	}Transition t0
					whenTime 10000	     -> moveToHome
					whenRequest reqenter -> acceptin
				
	
	State readyOnlyOutdoor{
		println("OUTDOOR Avaiable | SERVICE")
	}Transition t0
					whenTime 5000	     -> moveToHome
					whenMsg		pickup	 -> acceptout
					
					
	State notReady{
	}Transition t0
			whenTime 1000 -> check
					
					
	State moveToHome{
		[# if(unibo.robot.TrolleyKb.trolleyStatus == `it.unibo`.utils.TrolleyStatus.IDLE  && GOAL != "home") { #]
			println("##### IN MOVE TO HOME ##########")
		println("Moving Trolley to HOME")
		[# GOAL = "home" #]
		forward trolley -m move : move($GOAL) 
		[# } #]
	} Goto check				
	
 	 
	State acceptin{
			//================[ acceptIN ]=====================	
			[# SLOTNUM = `it.unibo`.utils.ParkingSlotsKb.findSlot() #]
			[# `it.unibo`.utils.ParkingSlotsKb.setSlot(SLOTNUM, false) #]
			[# if(! `it.unibo`.utils.ParkingSlotsKb.indoorFree || 
					unibo.robot.TrolleyKb.trolleyStatus == `it.unibo`.utils.TrolleyStatus.STOPPED
			){ #]
				replyTo reqenter with waitIndoor : slotsnum ($SLOTNUM)
				updateResource [# "waitindoor(${SLOTNUM})" #]
			[# } #]
			[# else {#]
			//================[ informIN ]=====================
			replyTo reqenter with slotsnum : slotsnum ($SLOTNUM)
			println("SLOTNUM = $SLOTNUM | SERVICE" )
			updateResource [# "slotnum(${SLOTNUM})" #]
			[# } #]	
	} Transition t0
		whenTime 20000 -> timeoutParking
		whenRequest carenter -> carenter


	State timeoutParking{
		[# `it.unibo`.utils.ParkingSlotsKb.setSlot(SLOTNUM, true) #]
		println("TIMEOUT ENTER REQUEST, RETRY LATER| SERVICE" )
		replyTo reqenter with reqenterTimeout : slotsnum ($SLOTNUM)
	} Goto check
				
					
	State carenter{
		emit carindoorarrival : cia(car_arrived)  //questo lo deve catturare il weightsensor
		//================[ moveToIn ]=====================
			[# GOAL = "indoor" #]
			forward trolley -m move : move($GOAL) 
			println("Trolley is moving to Indoor | SERVICE")
		}Transition t0
			whenEvent weightsensor -> weightcheck
			
			
	State weightcheck{
		onMsg(weightsensor : weight(W)){
			[# 
				WEIGHT = payloadArg(0).toInt()
				println("Weight: " + WEIGHT)
			#]
			}
	} Goto waitTrolleyIndoor if [# WEIGHT > 0 #] else weightError	//qui credo ci vada un when event finished(GOAL) e poi nello stato dopo un controllo sul weight		
		
		
	State waitTrolleyIndoor{
	} Transition t0
			whenEvent finished -> receipt  //waits until Trolley is in INDOOR
			
							
	State weightError{
		println("Car not actual in INDOOR-AREA")
		//MOVE TO HOME???
	} Goto check
				
	
	State receipt{ 
		onMsg(finished : finished(GOAL)){
				[# trolleyPos = payloadArg(0) #]
			}
			[# if(trolleyPos == "indoor") { #]
				println("Trolley is in INDOOR| SERVICE")
				[# 	INDOORTOKEN = `it.unibo`.utils.ParkingSlotsKb.generateToken(SLOTNUM) #]
				//==========[receipt]==========
				replyTo carenter with receipt : receipt($INDOORTOKEN)
				updateResource [# "receipt(${INDOORTOKEN})" #]
		[# } #]
	} Goto moveToSlotIn if [# trolleyPos == "indoor"#]
						else waitTrolleyIndoor
			
			
	State moveToSlotIn{
		//========================[ moveToSlotIN ]========================
		[# 	GOAL = "p" + SLOTNUM.toString()	#] 
		forward trolley -m move : move($GOAL)
		println("Trolley moves from INDOOR to $SLOTNUM")
	} Transition t0 
			whenEvent finished -> checkPark
	
	
	State checkPark{
		onMsg(finished : finished(GOAL)){
				[# trolleyPos = payloadArg(0) #]
			}
	} Goto parkedCar if [# trolleyPos == GOAL #]
		else parkingError
		
		
	State parkedCar{
		println("Car is parked at p$SLOTNUM")
		[# FREESLOTS = `it.unibo`.utils.ParkingSlotsKb.checkSlots() #]
		forward guiupdater -m updateGui : slotLiberi($FREESLOTS)
		////updateResource [# "{\"slotLiberi\":\"$FREESLOTS\"}"  #]
		updateResource [# "freeslots(${FREESLOTS})" #]
	} Transition t0
			whenTime 500 -> check
	
	
	State parkingError{
		println("Parking Error")
	} Goto check
	
	
	State acceptout{
		//===========[ acceptOUT ]=====================
		//===========[ findSlot ]=====================
			onMsg (pickup : pickup(OUTDOORTOKEN)){
				[#  OUTDOORTOKEN = payloadArg(0).toString() #]}
				[# 	CARSLOTNUM = `it.unibo`.utils.ParkingSlotsKb.checkToken(OUTDOORTOKEN) #]
	} Goto picking if [# CARSLOTNUM > 0 #] else tokenError
	
	
	State picking{	 	
		//====================[moveToSlotOut]========================
		delay 1000
		[# `it.unibo`.utils.ParkingSlotsKb.setSlot(CARSLOTNUM, true) 
			GOAL = "p" + CARSLOTNUM.toString()
		#]
		forward trolley -m move : move($GOAL)
		println("Trolley picking car from slot $CARSLOTNUM | SERVICE")
	}
	Transition t0
				whenEvent finished -> checkCarPicked
	
	
	State checkCarPicked{
		onMsg(finished : finished(W)){
			[# 
				trolleyPos = payloadArg(0)
			#]
			}
	} Goto moveToOut if[# trolleyPos == GOAL #]
		else trolleyToPickingSlot
		
		
	State trolleyToPickingSlot{
		println("WAIT TROLLEY ARRIVE AT PICKING SLOT | SERVICE")
	}Transition t0
			whenTime 5000 -> check
			whenEvent finished -> checkCarPicked
			
			
	State moveToOut{
		//====================[moveToOut]========================
		[# GOAL = "outdoor" #]
		forward trolley -m move : move($GOAL)
	}Transition t0 	
				whenEvent  finished	-> carInOutdoor
	
	
	State carInOutdoor{
		onMsg(finished : finished(W)){
			[# trolleyPos = payloadArg(0) #]
			}
		[# if(simulatedsonar){#]	
			[# if (trolleyPos == "outdoor") {#]	
			emit caroutdoorarrival : coa(car_arrived)  //questo lo deve catturare il outsonar
			[# FREESLOTS = `it.unibo`.utils.ParkingSlotsKb.checkSlots() #]
			forward guiupdater -m updateGui : slotLiberi($FREESLOTS)
			////updateResource [# "{\"slotLiberi\":\"$FREESLOTS\"}"  #]
			updateResource [# "freeslots(${FREESLOTS})" #]
			println("Car is in Outdoor area | SERVICE")
			[# } 
		} #]
	} Goto check if [# trolleyPos == "outdoor" #]
		else outdoorError
	
	
	State outdoorError{
		println("outdoor Error")
		}Goto check
	
		
	State tokenError{
		println("Invalid insert Token!")
	} Goto check
	 			
	 				
}


//---------------------------------------------------------------------------------------//

QActor sonarhandler context ctxParkingservice{
	[#
		var distance	= 2000
	#]
	
	State s0 initial {
		println("OUTDOOR SONAR INIT | SONAR")
	}Transition t0 whenMsg startsonar -> start
	
	
	State start {
		println("OUTDOOR SONAR START | SONAR")
	}Transition t0 whenEvent sonaroutdoor -> handleSonarData
	
	
	State handleSonarData{
		onMsg(sonaroutdoor : distance(W)){
			[# distance = payloadArg(0).toInt() #]
			}
		[# if(distance < 30 && `it.unibo`.utils.ParkingSlotsKb.outdoorFree) {
				`it.unibo`.utils.ParkingSlotsKb.outdoorFree = false
				#]
				forward guiupdater -m updateGui : outdoorStatus(BUSY)
				////updateResource [# "{\"outdoorStatus\":\"BUSY\"}" #]
				updateResource [# "outdoor(BUSY)" #]
				forward outdoortimer -m starttimer : timer(on) 
				println("Car in OUTDOOR | SONAR")
			[# }
			else if(distance >= 30 && !`it.unibo`.utils.ParkingSlotsKb.outdoorFree) {
				`it.unibo`.utils.ParkingSlotsKb.outdoorFree = true #]
				forward guiupdater -m updateGui : outdoorStatus(FREE)
				////updateResource [# "{\"outdoorStatus\":\"FREE\"}" #]
				updateResource [# "outdoor(FREE)" #]
				forward outdoortimer -m stoptimer : timer(off) 
				[# } #]
	}Transition t0 whenEvent sonaroutdoor -> handleSonarData
}

//------------------------------------------------------------------------------------------------------//	

QActor trolleystopper context ctxParkingservice{
	
	State s0 initial {
	}Goto work
	 
	State work{
	}Transition t0
			whenMsg stopTrolley -> stopped
			
	State stopped{
		forward trolley -m stopTrolley : stop(manager)
	} Transition t0
		whenMsg resumeTrolley -> resumed
		
    State resumed{
    	forward trolley -m resumeTrolley : resume(manager)
    }Goto work
}

//======================================================================================

QActor trolley context ctxParkingservice{         
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "moveUnknown"
 
  var GOAL = "" 
  var STATUS = ""
 
  val mapname     = "parkingMap" 		 
  var Myself      = myself  
  var CurrentPlannedMove = ""
  var CurPath	= ""
  var CurSlot   = ""
  val planner = `it.unibo`.utils.TrolleySupport
#]  
 	State s0 initial { 	      
 		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		
 		run itunibo.planner.plannerUtil.loadRoomMap("$mapname")
 		run itunibo.planner.plannerUtil.initAI()

		run itunibo.planner.plannerUtil.showCurrentRobotState()  	
     	//run pathexecutil.register( Myself )
 
 		run unibo.robot.robotSupport.move( "h" )
 		delay 1000 
   		run unibo.robot.robotSupport.move( "l" )
		run unibo.robot.robotSupport.move( "r" )
 		discardMsg Off  //WE want receive any msg
 		
     	run itunibo.planner.plannerUtil.showMap()
     	run itunibo.planner.plannerUtil.showCurrentRobotState()
     	
     	//run itunibo.support.pathexecutil.register( Myself )      	
 	}Transition t0
 			whenMsg systemready -> setup
 			
 			
 	State setup{
		[# val DIR =  itunibo.planner.plannerUtil.getDirection() #]
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.IDLE #]
		[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
		forward guiupdater -m updateGui : robotPos(0,0)
		forward guiupdater -m updateGui : direction($DIR)
 		////updateResource [# "{\"robotPos\":\"0,0\"}" #]
     	////updateResource [# "{\"direction\":\"$DIR\"}" #]
     	updateResource [# "posRobot(0,0)" #]
     	updateResource [# "dirRobot(${DIR})" #]
 	}Goto work
	

	State work{
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.IDLE #]
		[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
		forward guiupdater -m updateGui : status($STATUS)
		////updateResource [# "{\"status\":\"$STATUS\"}" #]
		updateResource [# "trolleystatus(${STATUS})" #]
		println("basicrobot waiting ... | TROLLEY")  
	}Transition t0
		whenMsg move -> path
		whenMsg stopTrolley -> stopped	  
		
		
	State stopped{
		run unibo.robot.robotSupport.move( "h" )
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.STOPPED #]
		[# val STATUS =  unibo.robot.TrolleyKb.trolleyStatus #]
		forward guiupdater -m updateGui : status($STATUS)
		////updateResource [# "{\"status\":\"$STATUS\"}" #]
		updateResource [# "trolleystatus(${STATUS})" #] //test
		
	} Transition t0
			whenMsg resumeTrolley -> resume
	
	
	State path{
		onMsg(move : move(GOAL)){
			[# GOAL = payloadArg(0) #]
			forward guiupdater -m updateGui : curDest($GOAL)
			////updateResource [# "{\"curDest\":\"$GOAL\"}" #]
			updateResource [# "curDest(${GOAL}) "#] //test
			
			println("GOAL = $GOAL | TROLLEY")
			run planner.getPathPlan(GOAL)
			[# CurPath = itunibo.planner.plannerUtil.getActions().toString() #]
		}
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
		[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
		forward guiupdater -m updateGui : status($STATUS)
		////updateResource [# "{\"status\":\"$STATUS\"}" #]
		updateResource [# "trolleystatus(${STATUS})" #]
	} Goto execPlannedMoves if [# GOAL != "home" #] //test
		else checkInterrupt
		
		
 	State checkInterrupt{
 	}Transition t0 
 			whenTime 100   -> execPlannedMoves
 			whenMsg move   -> path
 			whenMsg stopTrolley   -> stopped
    
   
	State execPlannedMoves{   
		//delay 300
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
 		println("+++++++++++++++++++++++++++++++ $CurrentPlannedMove | TROLLEY")
 	}
 	Goto doMove if [# CurrentPlannedMove.length>0 #] else endPath //parkthecar
 
 
 	State doMove{ 	
 		[# StepTime = #] run unibo.robot.robotSupport.move( "$CurrentPlannedMove" )
 		//[# StepTime = StepTime+100 #]
 	}Transition t0 
 			whenTimeVar StepTime   -> checkObstacle 
 	
 	
 	State checkObstacle{
 	}Transition t0
 		whenTime 100 -> stepDone
 		whenEvent obstacle -> handleObstacle
 	
 	
 	 State stepDone{
 	 	printCurrentMessage
 	 	[#if (CurrentPlannedMove == "w" || CurrentPlannedMove == "s") {#]
 	 		run unibo.robot.robotSupport.move( "h" )
 	 	[#}#]
 		//updateResource [# "stepdone($CurrentPlannedMove)" #]
 		run itunibo.planner.plannerUtil.updateMap(  "$CurrentPlannedMove" )
 		
		[# val POSX = itunibo.planner.plannerUtil.getPosX() #]
		[# val POSY = itunibo.planner.plannerUtil.getPosY() #]
		[# val DIR =  itunibo.planner.plannerUtil.getDirection() #]
		forward guiupdater -m updateGui : robotPos($POSX,$POSY)
		forward guiupdater -m updateGui : direction($DIR)
     	////updateResource [# "{\"robotPos\":\"$posX,$posY\"}" #]
     	////updateResource [# "{\"direction\":\"DIR\"}" #]
 		updateResource [# "posRobot(${POSX},${POSY})" #]
     	updateResource [# "dirRobot(${DIR})" #]
  	} Transition t0
  				whenTime 100 -> checkHomeGoal 
  				whenMsg stopTrolley -> stopped
  				
  	
  	State checkHomeGoal{
  	}Goto execPlannedMoves if[# GOAL != "home" #]
		else checkInterrupt
 	
 	 
 	State endPath{
		[# var timeDelay = #] run planner.exactDir(GOAL)
		[# delay(timeDelay) #] 
 		println("path finished | TROLLEY")
 		run itunibo.planner.plannerUtil.showCurrentRobotState()
 		updateResource [# "endPath(${GOAL})" #]	//test
 		emit finished : finished($GOAL) 
 		println("finished($GOAL) | TROLLEY")
 		[# GOAL = "" #]
 	} Goto work
 	
 	
 	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		printCurrentMessage
	} Goto stepDone if[# !planner.checkObstacle(itunibo.planner.plannerUtil.getPosX(), itunibo.planner.plannerUtil.getPosY()) #]
		else restart


	State resume{
	}Goto restart if [# GOAL != "" #]
		else work


	State restart{
			run planner.getPathPlan(GOAL)
			[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
			[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
			forward guiupdater -m updateGui : status($STATUS)
			////updateResource [# "{\"status\":\"$STATUS\"}" #]
			updateResource [# "trolleystatus(${STATUS})" #]
	} Goto execPlannedMoves if [# GOAL != "home" #]
		else checkInterrupt
		
		 
}	