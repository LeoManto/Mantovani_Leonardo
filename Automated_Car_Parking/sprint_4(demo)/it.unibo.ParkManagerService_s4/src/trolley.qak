System trolleyservice

mqttBroker "broker.hivemq.com" : 1883 eventTopic "parkingArea/feedback"    

Dispatch move  : move(GOAL)
Event finished : finished(V)
Event obstacle : obstacle( T )

Context ctxTrolley  ip [host="127.0.0.1" port=5685]

QActor trolley context ctxTrolley{         
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "moveUnknown"
 
  var GOAL = "" 
  var STATUS = ""
 
  val mapname     = "parkingMap" 		 
  var Myself      = myself  
  var CurrentPlannedMove = ""
  var CurPath	= ""
  var CurSlot   = ""
  val planner = `it.unibo`.utils.TrolleySupport
#]  
 	State s0 initial { 	      
 		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		
 		run itunibo.planner.plannerUtil.loadRoomMap("$mapname")
 		run itunibo.planner.plannerUtil.initAI()

		
		
		run itunibo.planner.plannerUtil.showCurrentRobotState()  	
     	//run pathexecutil.register( Myself )
 
 		run unibo.robot.robotSupport.move( "h" )
 		delay 1000 
   		run unibo.robot.robotSupport.move( "l" )
		run unibo.robot.robotSupport.move( "r" )
 		discardMsg Off  //WE want receive any msg
 		
     	run itunibo.planner.plannerUtil.showMap()
     	run itunibo.planner.plannerUtil.showCurrentRobotState()
     	
     	run pathexecutil.register( Myself ) 
 		
 	}
	Goto work
	
	
	State work{ 
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.IDLE #]
		[# STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString() #]
		updateResource [# "status($STATUS)" #]
		println("basicrobot waiting ... | TROLLEY")  
	}Transition t0
		whenMsg move -> path	  
	
	
	State path{
		onMsg(move : move(GOAL)){
			[# GOAL = payloadArg(0) #]
			println("GOAL = $GOAL | TROLLEY")
			run planner.getPathPlan(GOAL)
			[# CurPath = itunibo.planner.plannerUtil.getActions().toString() #]
			updateResource [# "path($CurPath)" #]
		}
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
		[#STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString()#]
		updateResource [# "status($STATUS)" #]
		
	} Goto execPlannedMoves if [# GOAL != "home" #]
		else checkInterrupt
		
		
 	State checkInterrupt{
 	}Transition t0 
 			whenTime 100   -> execPlannedMoves
 			whenMsg move   -> path
    
   
	State execPlannedMoves{   
		//delay 300
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
 		println("+++++++++++++++++++++++++++++++ $CurrentPlannedMove | TROLLEY")
 	}
 	Goto doMove if [# CurrentPlannedMove.length>0 #] else halt //parkthecar
 
 
 	State doMove{ 	
 		[#StepTime = #] run unibo.robot.robotSupport.move( "$CurrentPlannedMove" ) 
 		//[# StepTime = StepTime+100 #]
 	}Transition t0 
 			whenTimeVar StepTime   -> checkObstacle   
 	
 	
 	State checkObstacle{
 	}Transition t0
 		whenTime 100 -> stepDone
 		whenEvent obstacle -> handleObstacle
 	
 	
 	 State stepDone{  
 	 	printCurrentMessage
 	 	[#if (CurrentPlannedMove == "w" || CurrentPlannedMove == "s") {#]
 	 		run unibo.robot.robotSupport.move( "h" )
 	 	[#}#]
 	 	
 		//updateResource [# itunibo.planner.plannerUtil.getMap() #]
 		updateResource [# "stepdone($CurrentPlannedMove)" #]
 		run itunibo.planner.plannerUtil.updateMap(  "$CurrentPlannedMove" )
 		
 		//run itunibo.planner.plannerUtil.showCurrentRobotState( )
 		//updateResource [# "stepDone" # ]
  	}  
 	Goto execPlannedMoves if[# GOAL != "home" #]
		else checkInterrupt
 	
 	 
 	State halt{
		[# var timeDelay = #] run planner.exactDir(GOAL)
		[# delay(timeDelay) #] 
 		println("path finished | TROLLEY")
 		run itunibo.planner.plannerUtil.showCurrentRobotState()
 		updateResource [# "finished($GOAL)" #]
 		emit finished : finished($GOAL) 
 		println("finished($GOAL) | TROLLEY")
 	} Goto work
 	
 	
 	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		println("basicrobot | handleObstacleeeeeeeeeeeeeeeeeeee CurrentMove=$CurrentMove")	
		printCurrentMessage
	} Goto stepDone if[# !planner.checkObstacle(itunibo.planner.plannerUtil.getPosX(), itunibo.planner.plannerUtil.getPosY()) #]
		else restart


	State restart{
		run planner.getPathPlan(GOAL)
		[# unibo.robot.TrolleyKb.trolleyStatus = `it.unibo`.utils.TrolleyStatus.WORKING #]
		[#STATUS = unibo.robot.TrolleyKb.trolleyStatus.toString()#]
		updateResource [# "status($STATUS)" #]
	} Goto execPlannedMoves if [# GOAL != "home" #]
		else checkInterrupt
		
		 
}	


/*State turnMove{
  		if [# CurrentPlannedMove == "l" || CurrentPlannedMove == "r"  #]{
  			run unibo.robot.robotSupport.move( "$CurrentPlannedMove" )
  		} 
 	}
  	Transition t0  whenMsg moveok   -> rotationDone
  				


 	State rotationDone{
 		run itunibo.planner.plannerUtil.updateMap(  "$CurrentPlannedMove" )
   		run itunibo.planner.plannerUtil.showCurrentRobotState( )
 	} 
 	 Transition t0 whenTime 300 -> execPlannedMoves */

/* 
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
			run unibo.robot.robotSupport.move( "${payloadArg(0)}" )
			[# CurrentMove =  "${payloadArg(0)}" #] 
			if [# CurrentMove != "h" #] { 
				updateResource [# "moveactivated($CurrentMove)" #]
			}
		}
	 }
	 Goto work  
	 
	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		println("basicrobot | handleObstacleeeeeeeeeeeeeeeeeeee CurrentMove=$CurrentMove")	
		printCurrentMessage
			//msg(obstacle,dispatch,distancefilter,basicrobot,obstacle(5),18)
		if[# CurrentMove == "w" #]{
			  
 			run unibo.robot.robotSupport.move( "s" ) 
			delay 100 //loose the control ...
			run unibo.robot.robotSupport.move( "h" ) 	 		    	
			
			 // collision Json      : emitted by the virtualrobot 
			 // obstacle(virtual)   : emitted by the virtualrobotSupport2021 when endmove=false
			 // obstacle(5)         : emitted by the distanceFilter
			 // obstacle(w)         : emitted by the basicrobot
			 
			onMsg( obstacle : obstacle( T ) ){ 
				[#	val TargetObs = payloadArg(0)  	#]
				if[# TargetObs == "5" #]{
					updateResource [# "obstacle(w)" #]
				}
			} 
		}else{ //CurrentMove != "w"
			updateResource [# "spurious" #]
		}  		
	}
	Goto work 
 
    State backstep{
		    delay 1500 //give time to the tester to manage the update
		    println("basicrobot | bakkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")	
			run unibo.robot.robotSupport.move( "s" ) 
			delay 100 //loose the control ...
			run unibo.robot.robotSupport.move( "h" ) 			    	
    }
    Goto work 
    
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone //stepPerhapsDone	//caused by p
		whenMsg  obstacle     -> stepFail		
        //whenMsg     cmd       -> execcmd
  	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done
		println("basicrobot | stepDone")
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		//println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" )  
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		onMsg( end : end( V ) ){ 
			println("basicrobot | endwork")
			updateResource [# "basicrobot(end)" #]	 		
			//run utils.virtualRobotSupportQak.terminatevr( )
		}
 		emit endall : endall(normal) 
 		terminate 1
	}  */